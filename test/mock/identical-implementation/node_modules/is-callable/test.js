'use strict';

/* eslint no-magic-numbers: 1 */

const test = require('tape');
const isCallable = require('./');
const hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';
const genFn = require('make-generator-function');
const arrowFn = require('make-arrow-function')();
const forEach = require('foreach');

const invokeFunction = function invokeFunction(str) {
    let result;
    try {
        /* eslint-disable no-new-func */
        const fn = Function(str);
        /* eslint-enable no-new-func */
        result = fn();
    } catch (e) {
        /**/
    }
    return result;
};

const classConstructor = invokeFunction('"use strict"; return class Foo {}');

const commentedClass = invokeFunction(
    '"use strict"; return class/*kkk*/\n//blah\n Bar\n//blah\n {}'
);

test('not callables', t => {
    t.test('non-number/string primitives', st => {
        st.notOk(isCallable(), 'undefined is not callable');
        st.notOk(isCallable(null), 'null is not callable');
        st.notOk(isCallable(false), 'false is not callable');
        st.notOk(isCallable(true), 'true is not callable');
        st.end();
    });

    t.notOk(isCallable([]), 'array is not callable');
    t.notOk(isCallable({}), 'object is not callable');
    t.notOk(isCallable(/a/g), 'regex literal is not callable');
    t.notOk(isCallable(new RegExp('a', 'g')), 'regex object is not callable');
    t.notOk(isCallable(new Date()), 'new Date() is not callable');

    t.test('numbers', st => {
        st.notOk(isCallable(42), 'number is not callable');
        st.notOk(isCallable(Object(42)), 'number object is not callable');
        st.notOk(isCallable(NaN), 'NaN is not callable');
        st.notOk(isCallable(Infinity), 'Infinity is not callable');
        st.end();
    });

    t.test('strings', st => {
        st.notOk(isCallable('foo'), 'string primitive is not callable');
        st.notOk(isCallable(Object('foo')), 'string object is not callable');
        st.end();
    });

    t.test('non-function with function in its [[Prototype]] chain', st => {
        const Foo = function Bar() {};
        Foo.prototype = function() {};
        st.equal(true, isCallable(Foo), 'sanity check: Foo is callable');
        st.equal(
            false,
            isCallable(new Foo()),
            'instance of Foo is not callable'
        );
        st.end();
    });

    t.end();
});

test('@@toStringTag', { skip: !hasSymbols || !Symbol.toStringTag }, t => {
    const fn = function() {
        return 3;
    };
    const fakeFunction = {
        toString() {
            return String(fn);
        },
        valueOf() {
            return fn;
        },
    };
    fakeFunction[Symbol.toStringTag] = 'Function';
    t.notOk(
        isCallable(fakeFunction),
        'fake Function with @@toStringTag "Function" is not callable'
    );
    t.end();
});

const typedArrayNames = [
    'Int8Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Int16Array',
    'Uint16Array',
    'Int32Array',
    'Uint32Array',
    'Float32Array',
    'Float64Array',
];

test('Functions', t => {
    t.ok(isCallable(() => {}), 'function is callable');
    t.ok(
        isCallable(function classFake() {}),
        'function with name containing "class" is callable'
    );
    t.ok(
        isCallable(() => ' class '),
        'function with string " class " is callable'
    );
    t.ok(isCallable(isCallable), 'isCallable is callable');
    t.end();
});

test('Typed Arrays', st => {
    forEach(typedArrayNames, typedArray => {
        if (typeof global[typedArray] !== 'undefined') {
            st.ok(isCallable(global[typedArray]), `${typedArray} is callable`);
        }
    });
    st.end();
});

test('Generators', { skip: !genFn }, t => {
    t.ok(isCallable(genFn), 'generator function is callable');
    t.end();
});

test('Arrow functions', { skip: !arrowFn }, t => {
    t.ok(isCallable(arrowFn), 'arrow function is callable');
    t.end();
});

test(
    '"Class" constructors',
    { skip: !classConstructor || !commentedClass },
    t => {
        t.notOk(
            isCallable(classConstructor),
            'class constructors are not callable'
        );
        t.notOk(
            isCallable(commentedClass),
            'class constructors with comments in the signature are not callable'
        );
        t.end();
    }
);
