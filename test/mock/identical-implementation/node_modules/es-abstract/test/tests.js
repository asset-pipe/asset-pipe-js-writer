'use strict';

const test = require('tape');

const forEach = require('foreach');
const is = require('object-is');
const debug = require('util').format;
const assign = require('object.assign');

const v = require('./helpers/values');
const diffOps = require('./diffOps');

const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

const getArraySubclassWithSpeciesConstructor = function getArraySubclass(
    speciesConstructor
) {
    const Bar = function Bar() {
        const inst = [];
        Object.setPrototypeOf(inst, Bar.prototype);
        Object.defineProperty(inst, 'constructor', { value: Bar });
        return inst;
    };
    Bar.prototype = Object.create(Array.prototype);
    Object.setPrototypeOf(Bar, Array);
    Object.defineProperty(Bar, Symbol.species, { value: speciesConstructor });

    return Bar;
};

const hasSpecies = v.hasSymbols && Symbol.species;

const es2015 = function ES2015(ES, ops, expectedMissing) {
    test('has expected operations', t => {
        const diff = diffOps(ES, ops);

        t.deepEqual(diff.extra, [], 'no extra ops');

        t.deepEqual(diff.missing, expectedMissing, 'no unexpected missing ops');

        t.end();
    });

    test('ToPrimitive', t => {
        t.test('primitives', st => {
            const testPrimitive = function(primitive) {
                st.ok(
                    is(ES.ToPrimitive(primitive), primitive),
                    `${debug(primitive)} is returned correctly`
                );
            };
            forEach(v.primitives, testPrimitive);
            st.end();
        });

        t.test('objects', st => {
            st.equal(
                ES.ToPrimitive(v.coercibleObject),
                3,
                'coercibleObject with no hint coerces to valueOf'
            );
            st.ok(
                is(ES.ToPrimitive({}), '[object Object]'),
                '{} with no hint coerces to Object#toString'
            );
            st.equal(
                ES.ToPrimitive(v.coercibleObject, Number),
                3,
                'coercibleObject with hint Number coerces to valueOf'
            );
            st.ok(
                is(ES.ToPrimitive({}, Number), '[object Object]'),
                '{} with hint Number coerces to NaN'
            );
            st.equal(
                ES.ToPrimitive(v.coercibleObject, String),
                42,
                'coercibleObject with hint String coerces to nonstringified toString'
            );
            st.equal(
                ES.ToPrimitive({}, String),
                '[object Object]',
                '{} with hint String coerces to Object#toString'
            );
            st.equal(
                ES.ToPrimitive(v.toStringOnlyObject),
                7,
                'toStringOnlyObject returns non-stringified toString'
            );
            st.equal(
                ES.ToPrimitive(v.valueOfOnlyObject),
                4,
                'valueOfOnlyObject returns valueOf'
            );
            st.throws(
                () => ES.ToPrimitive(v.uncoercibleObject),
                TypeError,
                'uncoercibleObject throws a TypeError'
            );
            st.end();
        });

        t.test('dates', st => {
            const invalid = new Date(NaN);
            st.equal(
                ES.ToPrimitive(invalid),
                Date.prototype.toString.call(invalid),
                'invalid Date coerces to Date#toString'
            );
            const now = new Date();
            st.equal(
                ES.ToPrimitive(now),
                Date.prototype.toString.call(now),
                'Date coerces to Date#toString'
            );
            st.end();
        });

        t.end();
    });

    test('ToBoolean', t => {
        t.equal(false, ES.ToBoolean(undefined), 'undefined coerces to false');
        t.equal(false, ES.ToBoolean(null), 'null coerces to false');
        t.equal(false, ES.ToBoolean(false), 'false returns false');
        t.equal(true, ES.ToBoolean(true), 'true returns true');

        t.test('numbers', st => {
            forEach([0, -0, NaN], falsyNumber => {
                st.equal(
                    false,
                    ES.ToBoolean(falsyNumber),
                    `falsy number ${falsyNumber} coerces to false`
                );
            });
            forEach([Infinity, 42, 1, -Infinity], truthyNumber => {
                st.equal(
                    true,
                    ES.ToBoolean(truthyNumber),
                    `truthy number ${truthyNumber} coerces to true`
                );
            });

            st.end();
        });

        t.equal(false, ES.ToBoolean(''), 'empty string coerces to false');
        t.equal(true, ES.ToBoolean('foo'), 'nonempty string coerces to true');

        t.test('objects', st => {
            forEach(v.objects, obj => {
                st.equal(true, ES.ToBoolean(obj), 'object coerces to true');
            });
            st.equal(
                true,
                ES.ToBoolean(v.uncoercibleObject),
                'uncoercibleObject coerces to true'
            );

            st.end();
        });

        t.end();
    });

    test('ToNumber', t => {
        t.ok(is(NaN, ES.ToNumber(undefined)), 'undefined coerces to NaN');
        t.ok(is(ES.ToNumber(null), 0), 'null coerces to +0');
        t.ok(is(ES.ToNumber(false), 0), 'false coerces to +0');
        t.equal(1, ES.ToNumber(true), 'true coerces to 1');

        t.test('numbers', st => {
            st.ok(is(NaN, ES.ToNumber(NaN)), 'NaN returns itself');
            forEach([0, -0, 42, Infinity, -Infinity], num => {
                st.equal(num, ES.ToNumber(num), `${num} returns itself`);
            });
            forEach(
                ['foo', '0', '4a', '2.0', 'Infinity', '-Infinity'],
                numString => {
                    st.ok(
                        is(+numString, ES.ToNumber(numString)),
                        `"${numString}" coerces to ${Number(numString)}`
                    );
                }
            );
            st.end();
        });

        t.test('objects', st => {
            forEach(v.objects, object => {
                st.ok(
                    is(
                        ES.ToNumber(object),
                        ES.ToNumber(ES.ToPrimitive(object))
                    ),
                    `object ${object} coerces to same as ToPrimitive of object does`
                );
            });
            st.throws(
                () => ES.ToNumber(v.uncoercibleObject),
                TypeError,
                'uncoercibleObject throws'
            );
            st.end();
        });

        t.test('binary literals', st => {
            st.equal(ES.ToNumber('0b10'), 2, '0b10 is 2');
            st.equal(
                ES.ToNumber({
                    toString() {
                        return '0b11';
                    },
                }),
                3,
                'Object that toStrings to 0b11 is 3'
            );

            st.equal(true, is(ES.ToNumber('0b12'), NaN), '0b12 is NaN');
            st.equal(
                true,
                is(
                    ES.ToNumber({
                        toString() {
                            return '0b112';
                        },
                    }),
                    NaN
                ),
                'Object that toStrings to 0b112 is NaN'
            );
            st.end();
        });

        t.test('octal literals', st => {
            st.equal(ES.ToNumber('0o10'), 8, '0o10 is 8');
            st.equal(
                ES.ToNumber({
                    toString() {
                        return '0o11';
                    },
                }),
                9,
                'Object that toStrings to 0o11 is 9'
            );

            st.equal(true, is(ES.ToNumber('0o18'), NaN), '0o18 is NaN');
            st.equal(
                true,
                is(
                    ES.ToNumber({
                        toString() {
                            return '0o118';
                        },
                    }),
                    NaN
                ),
                'Object that toStrings to 0o118 is NaN'
            );
            st.end();
        });

        t.test('signed hex numbers', st => {
            st.equal(true, is(ES.ToNumber('-0xF'), NaN), '-0xF is NaN');
            st.equal(
                true,
                is(ES.ToNumber(' -0xF '), NaN),
                'space-padded -0xF is NaN'
            );
            st.equal(true, is(ES.ToNumber('+0xF'), NaN), '+0xF is NaN');
            st.equal(
                true,
                is(ES.ToNumber(' +0xF '), NaN),
                'space-padded +0xF is NaN'
            );

            st.end();
        });

        t.test('trimming of whitespace and non-whitespace characters', st => {
            const whitespace =
                ' \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000';
            st.equal(
                0,
                ES.ToNumber(whitespace + 0 + whitespace),
                'whitespace is trimmed'
            );

            // Zero-width space (zws), next line character (nel), and non-character (bom) are not whitespace.
            const nonWhitespaces = {
                '\\u0085': '\u0085',
                '\\u200b': '\u200b',
                '\\ufffe': '\ufffe',
            };

            forEach(nonWhitespaces, (desc, nonWS) => {
                st.equal(
                    true,
                    is(ES.ToNumber(nonWS + 0 + nonWS), NaN),
                    `non-whitespace ${desc} not trimmed`
                );
            });

            st.end();
        });

        forEach(v.symbols, symbol => {
            t.throws(
                () => {
                    ES.ToNumber(symbol);
                },
                TypeError,
                `Symbols canâ€™t be converted to a Number: ${debug(symbol)}`
            );
        });

        t.test('dates', st => {
            const invalid = new Date(NaN);
            st.ok(is(ES.ToNumber(invalid), NaN), 'invalid Date coerces to NaN');
            const now = Date.now();
            st.equal(
                ES.ToNumber(new Date(now)),
                now,
                'Date coerces to timestamp'
            );
            st.end();
        });

        t.end();
    });

    test('ToInteger', t => {
        t.ok(is(0, ES.ToInteger(NaN)), 'NaN coerces to +0');
        forEach([0, Infinity, 42], num => {
            t.ok(is(num, ES.ToInteger(num)), `${num} returns itself`);
            t.ok(is(-num, ES.ToInteger(-num)), `-${num} returns itself`);
        });
        t.equal(3, ES.ToInteger(Math.PI), 'pi returns 3');
        t.throws(
            () => ES.ToInteger(v.uncoercibleObject),
            TypeError,
            'uncoercibleObject throws'
        );
        t.end();
    });

    test('ToInt32', t => {
        t.ok(is(0, ES.ToInt32(NaN)), 'NaN coerces to +0');
        forEach([0, Infinity], num => {
            t.ok(is(0, ES.ToInt32(num)), `${num} returns +0`);
            t.ok(is(0, ES.ToInt32(-num)), `-${num} returns +0`);
        });
        t.throws(
            () => ES.ToInt32(v.uncoercibleObject),
            TypeError,
            'uncoercibleObject throws'
        );
        t.ok(is(ES.ToInt32(0x100000000), 0), '2^32 returns +0');
        t.ok(is(ES.ToInt32(0x100000000 - 1), -1), '2^32 - 1 returns -1');
        t.ok(is(ES.ToInt32(0x80000000), -0x80000000), '2^31 returns -2^31');
        t.ok(
            is(ES.ToInt32(0x80000000 - 1), 0x80000000 - 1),
            '2^31 - 1 returns 2^31 - 1'
        );
        forEach(
            [0, Infinity, NaN, 0x100000000, 0x80000000, 0x10000, 0x42],
            num => {
                t.ok(
                    is(ES.ToInt32(num), ES.ToInt32(ES.ToUint32(num))),
                    `ToInt32(x) === ToInt32(ToUint32(x)) for 0x${num.toString(
                        16
                    )}`
                );
                t.ok(
                    is(ES.ToInt32(-num), ES.ToInt32(ES.ToUint32(-num))),
                    `ToInt32(x) === ToInt32(ToUint32(x)) for -0x${num.toString(
                        16
                    )}`
                );
            }
        );
        t.end();
    });

    test('ToUint32', t => {
        t.ok(is(0, ES.ToUint32(NaN)), 'NaN coerces to +0');
        forEach([0, Infinity], num => {
            t.ok(is(0, ES.ToUint32(num)), `${num} returns +0`);
            t.ok(is(0, ES.ToUint32(-num)), `-${num} returns +0`);
        });
        t.throws(
            () => ES.ToUint32(v.uncoercibleObject),
            TypeError,
            'uncoercibleObject throws'
        );
        t.ok(is(ES.ToUint32(0x100000000), 0), '2^32 returns +0');
        t.ok(
            is(ES.ToUint32(0x100000000 - 1), 0x100000000 - 1),
            '2^32 - 1 returns 2^32 - 1'
        );
        t.ok(is(ES.ToUint32(0x80000000), 0x80000000), '2^31 returns 2^31');
        t.ok(
            is(ES.ToUint32(0x80000000 - 1), 0x80000000 - 1),
            '2^31 - 1 returns 2^31 - 1'
        );
        forEach(
            [0, Infinity, NaN, 0x100000000, 0x80000000, 0x10000, 0x42],
            num => {
                t.ok(
                    is(ES.ToUint32(num), ES.ToUint32(ES.ToInt32(num))),
                    `ToUint32(x) === ToUint32(ToInt32(x)) for 0x${num.toString(
                        16
                    )}`
                );
                t.ok(
                    is(ES.ToUint32(-num), ES.ToUint32(ES.ToInt32(-num))),
                    `ToUint32(x) === ToUint32(ToInt32(x)) for -0x${num.toString(
                        16
                    )}`
                );
            }
        );
        t.end();
    });

    test('ToInt16', t => {
        t.ok(is(0, ES.ToInt16(NaN)), 'NaN coerces to +0');
        forEach([0, Infinity], num => {
            t.ok(is(0, ES.ToInt16(num)), `${num} returns +0`);
            t.ok(is(0, ES.ToInt16(-num)), `-${num} returns +0`);
        });
        t.throws(
            () => ES.ToInt16(v.uncoercibleObject),
            TypeError,
            'uncoercibleObject throws'
        );
        t.ok(is(ES.ToInt16(0x100000000), 0), '2^32 returns +0');
        t.ok(is(ES.ToInt16(0x100000000 - 1), -1), '2^32 - 1 returns -1');
        t.ok(is(ES.ToInt16(0x80000000), 0), '2^31 returns +0');
        t.ok(is(ES.ToInt16(0x80000000 - 1), -1), '2^31 - 1 returns -1');
        t.ok(is(ES.ToInt16(0x10000), 0), '2^16 returns +0');
        t.ok(is(ES.ToInt16(0x10000 - 1), -1), '2^16 - 1 returns -1');
        t.end();
    });

    test('ToUint16', t => {
        t.ok(is(0, ES.ToUint16(NaN)), 'NaN coerces to +0');
        forEach([0, Infinity], num => {
            t.ok(is(0, ES.ToUint16(num)), `${num} returns +0`);
            t.ok(is(0, ES.ToUint16(-num)), `-${num} returns +0`);
        });
        t.throws(
            () => ES.ToUint16(v.uncoercibleObject),
            TypeError,
            'uncoercibleObject throws'
        );
        t.ok(is(ES.ToUint16(0x100000000), 0), '2^32 returns +0');
        t.ok(
            is(ES.ToUint16(0x100000000 - 1), 0x10000 - 1),
            '2^32 - 1 returns 2^16 - 1'
        );
        t.ok(is(ES.ToUint16(0x80000000), 0), '2^31 returns +0');
        t.ok(
            is(ES.ToUint16(0x80000000 - 1), 0x10000 - 1),
            '2^31 - 1 returns 2^16 - 1'
        );
        t.ok(is(ES.ToUint16(0x10000), 0), '2^16 returns +0');
        t.ok(
            is(ES.ToUint16(0x10000 - 1), 0x10000 - 1),
            '2^16 - 1 returns 2^16 - 1'
        );
        t.end();
    });

    test('ToInt8', t => {
        t.ok(is(0, ES.ToInt8(NaN)), 'NaN coerces to +0');
        forEach([0, Infinity], num => {
            t.ok(is(0, ES.ToInt8(num)), `${num} returns +0`);
            t.ok(is(0, ES.ToInt8(-num)), `-${num} returns +0`);
        });
        t.throws(
            () => ES.ToInt8(v.uncoercibleObject),
            TypeError,
            'uncoercibleObject throws'
        );
        t.ok(is(ES.ToInt8(0x100000000), 0), '2^32 returns +0');
        t.ok(is(ES.ToInt8(0x100000000 - 1), -1), '2^32 - 1 returns -1');
        t.ok(is(ES.ToInt8(0x80000000), 0), '2^31 returns +0');
        t.ok(is(ES.ToInt8(0x80000000 - 1), -1), '2^31 - 1 returns -1');
        t.ok(is(ES.ToInt8(0x10000), 0), '2^16 returns +0');
        t.ok(is(ES.ToInt8(0x10000 - 1), -1), '2^16 - 1 returns -1');
        t.ok(is(ES.ToInt8(0x100), 0), '2^8 returns +0');
        t.ok(is(ES.ToInt8(0x100 - 1), -1), '2^8 - 1 returns -1');
        t.ok(is(ES.ToInt8(0x10), 0x10), '2^4 returns 2^4');
        t.end();
    });

    test('ToUint8', t => {
        t.ok(is(0, ES.ToUint8(NaN)), 'NaN coerces to +0');
        forEach([0, Infinity], num => {
            t.ok(is(0, ES.ToUint8(num)), `${num} returns +0`);
            t.ok(is(0, ES.ToUint8(-num)), `-${num} returns +0`);
        });
        t.throws(
            () => ES.ToUint8(v.uncoercibleObject),
            TypeError,
            'uncoercibleObject throws'
        );
        t.ok(is(ES.ToUint8(0x100000000), 0), '2^32 returns +0');
        t.ok(
            is(ES.ToUint8(0x100000000 - 1), 0x100 - 1),
            '2^32 - 1 returns 2^8 - 1'
        );
        t.ok(is(ES.ToUint8(0x80000000), 0), '2^31 returns +0');
        t.ok(
            is(ES.ToUint8(0x80000000 - 1), 0x100 - 1),
            '2^31 - 1 returns 2^8 - 1'
        );
        t.ok(is(ES.ToUint8(0x10000), 0), '2^16 returns +0');
        t.ok(
            is(ES.ToUint8(0x10000 - 1), 0x100 - 1),
            '2^16 - 1 returns 2^8 - 1'
        );
        t.ok(is(ES.ToUint8(0x100), 0), '2^8 returns +0');
        t.ok(is(ES.ToUint8(0x100 - 1), 0x100 - 1), '2^8 - 1 returns 2^16 - 1');
        t.ok(is(ES.ToUint8(0x10), 0x10), '2^4 returns 2^4');
        t.ok(is(ES.ToUint8(0x10 - 1), 0x10 - 1), '2^4 - 1 returns 2^4 - 1');
        t.end();
    });

    test('ToUint8Clamp', t => {
        t.ok(is(0, ES.ToUint8Clamp(NaN)), 'NaN coerces to +0');
        t.ok(is(0, ES.ToUint8Clamp(0)), '+0 returns +0');
        t.ok(is(0, ES.ToUint8Clamp(-0)), '-0 returns +0');
        t.ok(is(0, ES.ToUint8Clamp(-Infinity)), '-Infinity returns +0');
        t.throws(
            () => ES.ToUint8Clamp(v.uncoercibleObject),
            TypeError,
            'uncoercibleObject throws'
        );
        forEach([255, 256, 0x100000, Infinity], number => {
            t.ok(is(255, ES.ToUint8Clamp(number)), `${number} coerces to 255`);
        });
        t.equal(1, ES.ToUint8Clamp(1.49), '1.49 coerces to 1');
        t.equal(2, ES.ToUint8Clamp(1.5), '1.5 coerces to 2, because 2 is even');
        t.equal(2, ES.ToUint8Clamp(1.51), '1.51 coerces to 2');

        t.equal(2, ES.ToUint8Clamp(2.49), '2.49 coerces to 2');
        t.equal(2, ES.ToUint8Clamp(2.5), '2.5 coerces to 2, because 2 is even');
        t.equal(3, ES.ToUint8Clamp(2.51), '2.51 coerces to 3');
        t.end();
    });

    test('ToString', t => {
        forEach(v.objects.concat(v.nonSymbolPrimitives), item => {
            t.equal(
                ES.ToString(item),
                String(item),
                `ES.ToString(${debug(item)}) ToStrings to String(${debug(
                    item
                )})`
            );
        });

        t.throws(
            () => ES.ToString(v.uncoercibleObject),
            TypeError,
            'uncoercibleObject throws'
        );

        forEach(v.symbols, symbol => {
            t.throws(
                () => ES.ToString(symbol),
                TypeError,
                `${debug(symbol)} throws`
            );
        });
        t.end();
    });

    test('ToObject', t => {
        t.throws(() => ES.ToObject(undefined), TypeError, 'undefined throws');
        t.throws(() => ES.ToObject(null), TypeError, 'null throws');
        forEach(v.numbers, number => {
            const obj = ES.ToObject(number);
            t.equal(typeof obj, 'object', `number ${number} coerces to object`);
            t.equal(
                true,
                obj instanceof Number,
                `object of ${number} is Number object`
            );
            t.ok(
                is(obj.valueOf(), number),
                `object of ${number} coerces to ${number}`
            );
        });
        t.end();
    });

    test('RequireObjectCoercible', t => {
        t.equal(
            false,
            'CheckObjectCoercible' in ES,
            'CheckObjectCoercible -> RequireObjectCoercible in ES6'
        );
        t.throws(
            () => ES.RequireObjectCoercible(undefined),
            TypeError,
            'undefined throws'
        );
        t.throws(
            () => ES.RequireObjectCoercible(null),
            TypeError,
            'null throws'
        );
        const isCoercible = function(value) {
            t.doesNotThrow(
                () => ES.RequireObjectCoercible(value),
                `${debug(value)} does not throw`
            );
        };
        forEach(v.objects.concat(v.nonNullPrimitives), isCoercible);
        t.end();
    });

    test('IsCallable', t => {
        t.equal(true, ES.IsCallable(() => {}), 'function is callable');
        const nonCallables = [/a/g, {}, Object.prototype, NaN].concat(
            v.primitives
        );
        forEach(nonCallables, nonCallable => {
            t.equal(
                false,
                ES.IsCallable(nonCallable),
                `${debug(nonCallable)} is not callable`
            );
        });
        t.end();
    });

    test('SameValue', t => {
        t.equal(true, ES.SameValue(NaN, NaN), 'NaN is SameValue as NaN');
        t.equal(false, ES.SameValue(0, -0), '+0 is not SameValue as -0');
        forEach(v.objects.concat(v.primitives), val => {
            t.equal(
                val === val,
                ES.SameValue(val, val),
                `${debug(val)} is SameValue to itself`
            );
        });
        t.end();
    });

    test('SameValueZero', t => {
        t.equal(
            true,
            ES.SameValueZero(NaN, NaN),
            'NaN is SameValueZero as NaN'
        );
        t.equal(true, ES.SameValueZero(0, -0), '+0 is SameValueZero as -0');
        forEach(v.objects.concat(v.primitives), val => {
            t.equal(
                val === val,
                ES.SameValueZero(val, val),
                `${debug(val)} is SameValueZero to itself`
            );
        });
        t.end();
    });

    test('ToPropertyKey', t => {
        forEach(v.objects.concat(v.nonSymbolPrimitives), value => {
            t.equal(
                ES.ToPropertyKey(value),
                String(value),
                'ToPropertyKey(value) === String(value) for non-Symbols'
            );
        });

        forEach(v.symbols, symbol => {
            t.equal(
                ES.ToPropertyKey(symbol),
                symbol,
                `ToPropertyKey(${debug(symbol)}) === ${debug(symbol)}`
            );
            t.equal(
                ES.ToPropertyKey(Object(symbol)),
                symbol,
                `ToPropertyKey(${debug(Object(symbol))}) === ${debug(symbol)}`
            );
        });

        t.end();
    });

    test('ToLength', t => {
        t.throws(
            () => ES.ToLength(v.uncoercibleObject),
            TypeError,
            'uncoercibleObject throws a TypeError'
        );
        t.equal(
            3,
            ES.ToLength(v.coercibleObject),
            'coercibleObject coerces to 3'
        );
        t.equal(42, ES.ToLength('42.5'), '"42.5" coerces to 42');
        t.equal(7, ES.ToLength(7.3), '7.3 coerces to 7');
        forEach([-0, -1, -42, -Infinity], negative => {
            t.ok(is(0, ES.ToLength(negative)), `${negative} coerces to +0`);
        });
        t.equal(
            MAX_SAFE_INTEGER,
            ES.ToLength(MAX_SAFE_INTEGER + 1),
            '2^53 coerces to 2^53 - 1'
        );
        t.equal(
            MAX_SAFE_INTEGER,
            ES.ToLength(MAX_SAFE_INTEGER + 3),
            '2^53 + 2 coerces to 2^53 - 1'
        );
        t.end();
    });

    test('IsArray', t => {
        t.equal(true, ES.IsArray([]), '[] is array');
        t.equal(false, ES.IsArray({}), '{} is not array');
        t.equal(
            false,
            ES.IsArray({ length: 1, 0: true }),
            'arraylike object is not array'
        );
        forEach(v.objects.concat(v.primitives), value => {
            t.equal(false, ES.IsArray(value), `${debug(value)} is not array`);
        });
        t.end();
    });

    test('IsRegExp', t => {
        forEach([/a/g, new RegExp('a', 'g')], regex => {
            t.equal(true, ES.IsRegExp(regex), `${regex} is regex`);
        });

        forEach(v.objects.concat(v.primitives), nonRegex => {
            t.equal(
                false,
                ES.IsRegExp(nonRegex),
                `${debug(nonRegex)} is not regex`
            );
        });

        t.test('Symbol.match', { skip: !v.hasSymbols || !Symbol.match }, st => {
            const obj = {};
            obj[Symbol.match] = true;
            st.equal(
                true,
                ES.IsRegExp(obj),
                'object with truthy Symbol.match is regex'
            );

            const regex = /a/;
            regex[Symbol.match] = false;
            st.equal(
                false,
                ES.IsRegExp(regex),
                'regex with falsy Symbol.match is not regex'
            );

            st.end();
        });

        t.end();
    });

    test('IsPropertyKey', t => {
        forEach(v.numbers.concat(v.objects), notKey => {
            t.equal(
                false,
                ES.IsPropertyKey(notKey),
                `${debug(notKey)} is not property key`
            );
        });

        t.equal(true, ES.IsPropertyKey('foo'), 'string is property key');

        forEach(v.symbols, symbol => {
            t.equal(
                true,
                ES.IsPropertyKey(symbol),
                `${debug(symbol)} is property key`
            );
        });
        t.end();
    });

    test('IsInteger', t => {
        for (let i = -100; i < 100; i += 10) {
            t.equal(true, ES.IsInteger(i), `${i} is integer`);
            t.equal(false, ES.IsInteger(i + 0.2), `${i + 0.2} is not integer`);
        }
        t.equal(true, ES.IsInteger(-0), '-0 is integer');
        const notInts = v.nonNumbers.concat(v.nonIntegerNumbers, [
            Infinity,
            -Infinity,
            NaN,
            [],
            new Date(),
        ]);
        forEach(notInts, notInt => {
            t.equal(
                false,
                ES.IsInteger(notInt),
                `${debug(notInt)} is not integer`
            );
        });
        t.equal(
            false,
            ES.IsInteger(v.uncoercibleObject),
            'uncoercibleObject is not integer'
        );
        t.end();
    });

    test('IsExtensible', t => {
        forEach(v.objects, object => {
            t.equal(
                true,
                ES.IsExtensible(object),
                `${debug(object)} object is extensible`
            );
        });
        forEach(v.primitives, primitive => {
            t.equal(
                false,
                ES.IsExtensible(primitive),
                `${debug(primitive)} is not extensible`
            );
        });
        if (Object.preventExtensions) {
            t.equal(
                false,
                ES.IsExtensible(Object.preventExtensions({})),
                'object with extensions prevented is not extensible'
            );
        }
        t.end();
    });

    test('CanonicalNumericIndexString', t => {
        const throwsOnNonString = function(notString) {
            t.throws(
                () => ES.CanonicalNumericIndexString(notString),
                TypeError,
                `${debug(notString)} is not a string`
            );
        };
        forEach(v.objects.concat(v.numbers), throwsOnNonString);
        t.ok(is(-0, ES.CanonicalNumericIndexString('-0')), '"-0" returns -0');
        for (let i = -50; i < 50; i += 10) {
            t.equal(
                i,
                ES.CanonicalNumericIndexString(String(i)),
                `"${i}" returns ${i}`
            );
            t.equal(
                undefined,
                ES.CanonicalNumericIndexString(`${String(i)}a`),
                `"${i}a" returns undefined`
            );
        }
        t.end();
    });

    test('IsConstructor', t => {
        t.equal(true, ES.IsConstructor(() => {}), 'function is constructor');
        t.equal(false, ES.IsConstructor(/a/g), 'regex is not constructor');
        forEach(v.objects, object => {
            t.equal(
                false,
                ES.IsConstructor(object),
                `${object} object is not constructor`
            );
        });

        try {
            const foo = Function('return class Foo {}')(); // eslint-disable-line no-new-func
            t.equal(ES.IsConstructor(foo), true, 'class is constructor');
        } catch (e) {
            t.comment('SKIP: class syntax not supported.');
        }
        t.end();
    });

    test('Call', t => {
        const receiver = {};
        const notFuncs = v.objects
            .concat(v.primitives)
            .concat([/a/g, new RegExp('a', 'g')]);
        t.plan(notFuncs.length + 4);
        const throwsIfNotCallable = function(notFunc) {
            t.throws(
                () => ES.Call(notFunc, receiver),
                TypeError,
                `${debug(notFunc)} (${typeof notFunc}) is not callable`
            );
        };
        forEach(notFuncs, throwsIfNotCallable);
        ES.Call(
            function(a, b) {
                t.equal(this, receiver, 'context matches expected');
                t.deepEqual([a, b], [1, 2], 'named args are correct');
                t.equal(arguments.length, 3, 'extra argument was passed');
                t.equal(arguments[2], 3, 'extra argument was correct');
            },
            receiver,
            [1, 2, 3]
        );
        t.end();
    });

    test('GetV', t => {
        t.throws(
            () => ES.GetV({ 7: 7 }, 7),
            TypeError,
            'Throws a TypeError if `P` is not a property key'
        );
        const obj = { a() {} };
        t.equal(ES.GetV(obj, 'a'), obj.a, 'returns property if it exists');
        t.equal(
            ES.GetV(obj, 'b'),
            undefined,
            'returns undefiend if property does not exist'
        );
        t.end();
    });

    test('GetMethod', t => {
        t.throws(
            () => ES.GetMethod({ 7: 7 }, 7),
            TypeError,
            'Throws a TypeError if `P` is not a property key'
        );
        t.equal(
            ES.GetMethod({}, 'a'),
            undefined,
            'returns undefined in property is undefined'
        );
        t.equal(
            ES.GetMethod({ a: null }, 'a'),
            undefined,
            'returns undefined if property is null'
        );
        t.equal(
            ES.GetMethod({ a: undefined }, 'a'),
            undefined,
            'returns undefined if property is undefined'
        );
        const obj = { a() {} };
        t.throws(
            () => {
                ES.GetMethod({ a: 'b' }, 'a');
            },
            TypeError,
            'throws TypeError if property exists and is not callable'
        );
        t.equal(
            ES.GetMethod(obj, 'a'),
            obj.a,
            'returns property if it is callable'
        );
        t.end();
    });

    test('Get', t => {
        t.throws(
            () => ES.Get('a', 'a'),
            TypeError,
            'Throws a TypeError if `O` is not an Object'
        );
        t.throws(
            () => ES.Get({ 7: 7 }, 7),
            TypeError,
            'Throws a TypeError if `P` is not a property key'
        );

        const value = {};
        t.test('Symbols', { skip: !v.hasSymbols }, st => {
            const sym = Symbol('sym');
            const obj = {};
            obj[sym] = value;
            st.equal(
                ES.Get(obj, sym),
                value,
                'returns property `P` if it exists on object `O`'
            );
            st.end();
        });
        t.equal(
            ES.Get({ a: value }, 'a'),
            value,
            'returns property `P` if it exists on object `O`'
        );
        t.end();
    });

    test('Type', { skip: !v.hasSymbols }, t => {
        t.equal(
            ES.Type(Symbol.iterator),
            'Symbol',
            'Type(Symbol.iterator) is Symbol'
        );
        t.end();
    });

    test('SpeciesConstructor', t => {
        t.throws(() => {
            ES.SpeciesConstructor(null);
        }, TypeError);
        t.throws(() => {
            ES.SpeciesConstructor(undefined);
        }, TypeError);

        const defaultConstructor = function Foo() {};

        t.equal(
            ES.SpeciesConstructor(
                { constructor: undefined },
                defaultConstructor
            ),
            defaultConstructor,
            'undefined constructor returns defaultConstructor'
        );

        t.throws(
            () =>
                ES.SpeciesConstructor(
                    { constructor: null },
                    defaultConstructor
                ),
            TypeError,
            'non-undefined non-object constructor throws'
        );

        t.test('with Symbol.species', { skip: !hasSpecies }, st => {
            const Bar = function Bar() {};
            Bar[Symbol.species] = null;

            st.equal(
                ES.SpeciesConstructor(new Bar(), defaultConstructor),
                defaultConstructor,
                'undefined/null Symbol.species returns default constructor'
            );

            const Baz = function Baz() {};
            Baz[Symbol.species] = Bar;
            st.equal(
                ES.SpeciesConstructor(new Baz(), defaultConstructor),
                Bar,
                'returns Symbol.species constructor value'
            );

            Baz[Symbol.species] = {};
            st.throws(
                () => {
                    ES.SpeciesConstructor(new Baz(), defaultConstructor);
                },
                TypeError,
                'throws when non-constructor non-null non-undefined species value found'
            );

            st.end();
        });

        t.end();
    });

    const bothDescriptor = function() {
        return { '[[Get]]'() {}, '[[Value]]': true };
    };
    const accessorDescriptor = function() {
        return {
            '[[Get]]'() {},
            '[[Enumerable]]': true,
            '[[Configurable]]': true,
        };
    };
    const mutatorDescriptor = function() {
        return {
            '[[Set]]'() {},
            '[[Enumerable]]': true,
            '[[Configurable]]': true,
        };
    };
    const dataDescriptor = function() {
        return {
            '[[Value]]': 42,
            '[[Writable]]': false,
        };
    };
    const genericDescriptor = function() {
        return {
            '[[Configurable]]': true,
            '[[Enumerable]]': false,
        };
    };

    test('IsPropertyDescriptor', t => {
        forEach(v.nonUndefinedPrimitives, primitive => {
            t.equal(
                ES.IsPropertyDescriptor(primitive),
                false,
                `${debug(primitive)} is not a Property Descriptor`
            );
        });

        t.equal(
            ES.IsPropertyDescriptor({ invalid: true }),
            false,
            'invalid keys not allowed on a Property Descriptor'
        );

        t.equal(
            ES.IsPropertyDescriptor({}),
            true,
            'empty object is an incomplete Property Descriptor'
        );

        t.equal(
            ES.IsPropertyDescriptor(accessorDescriptor()),
            true,
            'accessor descriptor is a Property Descriptor'
        );
        t.equal(
            ES.IsPropertyDescriptor(mutatorDescriptor()),
            true,
            'mutator descriptor is a Property Descriptor'
        );
        t.equal(
            ES.IsPropertyDescriptor(dataDescriptor()),
            true,
            'data descriptor is a Property Descriptor'
        );
        t.equal(
            ES.IsPropertyDescriptor(genericDescriptor()),
            true,
            'generic descriptor is a Property Descriptor'
        );

        t.throws(
            () => {
                ES.IsPropertyDescriptor(bothDescriptor());
            },
            TypeError,
            'a Property Descriptor can not be both a Data and an Accessor Descriptor'
        );

        t.end();
    });

    test('IsAccessorDescriptor', t => {
        forEach(v.nonUndefinedPrimitives, primitive => {
            t.throws(
                () => {
                    ES.IsAccessorDescriptor(primitive);
                },
                TypeError,
                `${debug(primitive)} is not a Property Descriptor`
            );
        });

        t.equal(
            ES.IsAccessorDescriptor(),
            false,
            'no value is not an Accessor Descriptor'
        );
        t.equal(
            ES.IsAccessorDescriptor(undefined),
            false,
            'undefined value is not an Accessor Descriptor'
        );

        t.equal(
            ES.IsAccessorDescriptor(accessorDescriptor()),
            true,
            'accessor descriptor is an Accessor Descriptor'
        );
        t.equal(
            ES.IsAccessorDescriptor(mutatorDescriptor()),
            true,
            'mutator descriptor is an Accessor Descriptor'
        );
        t.equal(
            ES.IsAccessorDescriptor(dataDescriptor()),
            false,
            'data descriptor is not an Accessor Descriptor'
        );
        t.equal(
            ES.IsAccessorDescriptor(genericDescriptor()),
            false,
            'generic descriptor is not an Accessor Descriptor'
        );

        t.end();
    });

    test('IsDataDescriptor', t => {
        forEach(v.nonUndefinedPrimitives, primitive => {
            t.throws(
                () => {
                    ES.IsDataDescriptor(primitive);
                },
                TypeError,
                `${debug(primitive)} is not a Property Descriptor`
            );
        });

        t.equal(
            ES.IsDataDescriptor(),
            false,
            'no value is not a Data Descriptor'
        );
        t.equal(
            ES.IsDataDescriptor(undefined),
            false,
            'undefined value is not a Data Descriptor'
        );

        t.equal(
            ES.IsDataDescriptor(accessorDescriptor()),
            false,
            'accessor descriptor is not a Data Descriptor'
        );
        t.equal(
            ES.IsDataDescriptor(mutatorDescriptor()),
            false,
            'mutator descriptor is not a Data Descriptor'
        );
        t.equal(
            ES.IsDataDescriptor(dataDescriptor()),
            true,
            'data descriptor is a Data Descriptor'
        );
        t.equal(
            ES.IsDataDescriptor(genericDescriptor()),
            false,
            'generic descriptor is not a Data Descriptor'
        );

        t.end();
    });

    test('IsGenericDescriptor', t => {
        forEach(v.nonUndefinedPrimitives, primitive => {
            t.throws(
                () => {
                    ES.IsGenericDescriptor(primitive);
                },
                TypeError,
                `${debug(primitive)} is not a Property Descriptor`
            );
        });

        t.equal(
            ES.IsGenericDescriptor(),
            false,
            'no value is not a Data Descriptor'
        );
        t.equal(
            ES.IsGenericDescriptor(undefined),
            false,
            'undefined value is not a Data Descriptor'
        );

        t.equal(
            ES.IsGenericDescriptor(accessorDescriptor()),
            false,
            'accessor descriptor is not a generic Descriptor'
        );
        t.equal(
            ES.IsGenericDescriptor(mutatorDescriptor()),
            false,
            'mutator descriptor is not a generic Descriptor'
        );
        t.equal(
            ES.IsGenericDescriptor(dataDescriptor()),
            false,
            'data descriptor is not a generic Descriptor'
        );

        t.equal(
            ES.IsGenericDescriptor(genericDescriptor()),
            true,
            'generic descriptor is a generic Descriptor'
        );

        t.end();
    });

    test('FromPropertyDescriptor', t => {
        t.equal(
            ES.FromPropertyDescriptor(),
            undefined,
            'no value begets undefined'
        );
        t.equal(
            ES.FromPropertyDescriptor(undefined),
            undefined,
            'undefined value begets undefined'
        );

        forEach(v.nonUndefinedPrimitives, primitive => {
            t.throws(
                () => {
                    ES.FromPropertyDescriptor(primitive);
                },
                TypeError,
                `${debug(primitive)} is not a Property Descriptor`
            );
        });

        const accessor = accessorDescriptor();
        t.deepEqual(ES.FromPropertyDescriptor(accessor), {
            get: accessor['[[Get]]'],
            set: accessor['[[Set]]'],
            enumerable: !!accessor['[[Enumerable]]'],
            configurable: !!accessor['[[Configurable]]'],
        });

        const mutator = mutatorDescriptor();
        t.deepEqual(ES.FromPropertyDescriptor(mutator), {
            get: mutator['[[Get]]'],
            set: mutator['[[Set]]'],
            enumerable: !!mutator['[[Enumerable]]'],
            configurable: !!mutator['[[Configurable]]'],
        });
        const data = dataDescriptor();
        t.deepEqual(ES.FromPropertyDescriptor(data), {
            value: data['[[Value]]'],
            writable: data['[[Writable]]'],
            enumerable: !!data['[[Enumerable]]'],
            configurable: !!data['[[Configurable]]'],
        });

        t.throws(
            () => {
                ES.FromPropertyDescriptor(genericDescriptor());
            },
            TypeError,
            'a complete Property Descriptor is required'
        );

        t.end();
    });

    test('ToPropertyDescriptor', t => {
        forEach(v.nonUndefinedPrimitives, primitive => {
            t.throws(
                () => {
                    ES.ToPropertyDescriptor(primitive);
                },
                TypeError,
                `${debug(primitive)} is not an Object`
            );
        });

        const accessor = accessorDescriptor();
        t.deepEqual(
            ES.ToPropertyDescriptor({
                get: accessor['[[Get]]'],
                enumerable: !!accessor['[[Enumerable]]'],
                configurable: !!accessor['[[Configurable]]'],
            }),
            accessor
        );

        const mutator = mutatorDescriptor();
        t.deepEqual(
            ES.ToPropertyDescriptor({
                set: mutator['[[Set]]'],
                enumerable: !!mutator['[[Enumerable]]'],
                configurable: !!mutator['[[Configurable]]'],
            }),
            mutator
        );

        const data = dataDescriptor();
        t.deepEqual(
            ES.ToPropertyDescriptor({
                value: data['[[Value]]'],
                writable: data['[[Writable]]'],
                configurable: !!data['[[Configurable]]'],
            }),
            assign(data, { '[[Configurable]]': false })
        );

        const both = bothDescriptor();
        t.throws(
            () => {
                ES.FromPropertyDescriptor({
                    get: both['[[Get]]'],
                    value: both['[[Value]]'],
                });
            },
            TypeError,
            'data and accessor descriptors are mutually exclusive'
        );

        t.end();
    });

    test('CompletePropertyDescriptor', t => {
        forEach(v.nonUndefinedPrimitives, primitive => {
            t.throws(
                () => {
                    ES.CompletePropertyDescriptor(primitive);
                },
                TypeError,
                `${debug(primitive)} is not a Property Descriptor`
            );
        });

        const generic = genericDescriptor();
        t.deepEqual(
            ES.CompletePropertyDescriptor(generic),
            {
                '[[Configurable]]': !!generic['[[Configurable]]'],
                '[[Enumerable]]': !!generic['[[Enumerable]]'],
                '[[Value]]': undefined,
                '[[Writable]]': false,
            },
            'completes a Generic Descriptor'
        );

        const data = dataDescriptor();
        t.deepEqual(
            ES.CompletePropertyDescriptor(data),
            {
                '[[Configurable]]': !!data['[[Configurable]]'],
                '[[Enumerable]]': false,
                '[[Value]]': data['[[Value]]'],
                '[[Writable]]': !!data['[[Writable]]'],
            },
            'completes a Data Descriptor'
        );

        const accessor = accessorDescriptor();
        t.deepEqual(
            ES.CompletePropertyDescriptor(accessor),
            {
                '[[Get]]': accessor['[[Get]]'],
                '[[Enumerable]]': !!accessor['[[Enumerable]]'],
                '[[Configurable]]': !!accessor['[[Configurable]]'],
                '[[Set]]': undefined,
            },
            'completes an Accessor Descriptor'
        );

        const mutator = mutatorDescriptor();
        t.deepEqual(
            ES.CompletePropertyDescriptor(mutator),
            {
                '[[Set]]': mutator['[[Set]]'],
                '[[Enumerable]]': !!mutator['[[Enumerable]]'],
                '[[Configurable]]': !!mutator['[[Configurable]]'],
                '[[Get]]': undefined,
            },
            'completes a mutator Descriptor'
        );

        t.throws(
            () => {
                ES.CompletePropertyDescriptor(bothDescriptor());
            },
            TypeError,
            'data and accessor descriptors are mutually exclusive'
        );

        t.end();
    });

    test('Set', t => {
        forEach(v.primitives, primitive => {
            t.throws(
                () => {
                    ES.Set(primitive, '', null, false);
                },
                TypeError,
                `${debug(primitive)} is not an Object`
            );
        });

        forEach(v.nonPropertyKeys, nonKey => {
            t.throws(
                () => {
                    ES.Set({}, nonKey, null, false);
                },
                TypeError,
                `${debug(nonKey)} is not a Property Key`
            );
        });

        forEach(v.nonBooleans, nonBoolean => {
            t.throws(
                () => {
                    ES.Set({}, '', null, nonBoolean);
                },
                TypeError,
                `${debug(nonBoolean)} is not a Boolean`
            );
        });

        const o = {};
        const value = {};
        ES.Set(o, 'key', value, true);
        t.deepEqual(o, { key: value }, 'key is set');

        t.test('nonwritable', { skip: !Object.defineProperty }, st => {
            const obj = { a: value };
            Object.defineProperty(obj, 'a', { writable: false });

            st.throws(
                () => {
                    ES.Set(obj, 'a', value, true);
                },
                TypeError,
                'can not Set nonwritable property'
            );

            st.doesNotThrow(() => {
                ES.Set(obj, 'a', value, false);
            }, 'setting Throw to false prevents an exception');

            st.end();
        });

        t.test('nonconfigurable', { skip: !Object.defineProperty }, st => {
            const obj = { a: value };
            Object.defineProperty(obj, 'a', { configurable: false });

            ES.Set(obj, 'a', value, true);
            st.deepEqual(obj, { a: value }, 'key is set');

            st.end();
        });

        t.end();
    });

    test('HasOwnProperty', t => {
        forEach(v.primitives, primitive => {
            t.throws(
                () => {
                    ES.HasOwnProperty(primitive, 'key');
                },
                TypeError,
                `${debug(primitive)} is not an Object`
            );
        });

        forEach(v.nonPropertyKeys, nonKey => {
            t.throws(
                () => {
                    ES.HasOwnProperty({}, nonKey);
                },
                TypeError,
                `${debug(nonKey)} is not a Property Key`
            );
        });

        t.equal(
            ES.HasOwnProperty({}, 'toString'),
            false,
            'inherited properties are not own'
        );
        t.equal(
            ES.HasOwnProperty({ toString: 1 }, 'toString'),
            true,
            'shadowed inherited own properties are own'
        );
        t.equal(
            ES.HasOwnProperty({ a: 1 }, 'a'),
            true,
            'own properties are own'
        );

        t.end();
    });

    test('HasProperty', t => {
        forEach(v.primitives, primitive => {
            t.throws(
                () => {
                    ES.HasProperty(primitive, 'key');
                },
                TypeError,
                `${debug(primitive)} is not an Object`
            );
        });

        forEach(v.nonPropertyKeys, nonKey => {
            t.throws(
                () => {
                    ES.HasProperty({}, nonKey);
                },
                TypeError,
                `${debug(nonKey)} is not a Property Key`
            );
        });

        t.equal(
            ES.HasProperty({}, 'nope'),
            false,
            'object does not have nonexistent properties'
        );
        t.equal(
            ES.HasProperty({}, 'toString'),
            true,
            'object has inherited properties'
        );
        t.equal(
            ES.HasProperty({ toString: 1 }, 'toString'),
            true,
            'object has shadowed inherited own properties'
        );
        t.equal(
            ES.HasProperty({ a: 1 }, 'a'),
            true,
            'object has own properties'
        );

        t.end();
    });

    test('IsConcatSpreadable', t => {
        forEach(v.primitives, primitive => {
            t.equal(
                ES.IsConcatSpreadable(primitive),
                false,
                `${debug(primitive)} is not an Object`
            );
        });

        const hasSymbolConcatSpreadable =
            v.hasSymbols && Symbol.isConcatSpreadable;
        t.test(
            'Symbol.isConcatSpreadable',
            { skip: !hasSymbolConcatSpreadable },
            st => {
                forEach(v.falsies, falsy => {
                    const obj = {};
                    obj[Symbol.isConcatSpreadable] = falsy;
                    st.equal(
                        ES.IsConcatSpreadable(obj),
                        false,
                        `an object with ${debug(
                            falsy
                        )} as Symbol.isConcatSpreadable is not concat spreadable`
                    );
                });

                forEach(v.truthies, truthy => {
                    const obj = {};
                    obj[Symbol.isConcatSpreadable] = truthy;
                    st.equal(
                        ES.IsConcatSpreadable(obj),
                        true,
                        `an object with ${debug(
                            truthy
                        )} as Symbol.isConcatSpreadable is concat spreadable`
                    );
                });

                st.end();
            }
        );

        forEach(v.objects, object => {
            t.equal(
                ES.IsConcatSpreadable(object),
                false,
                'non-array without Symbol.isConcatSpreadable is not concat spreadable'
            );
        });

        t.equal(
            ES.IsConcatSpreadable([]),
            true,
            'arrays are concat spreadable'
        );

        t.end();
    });

    test('Invoke', t => {
        forEach(v.nonPropertyKeys, nonKey => {
            t.throws(
                () => {
                    ES.Invoke({}, nonKey);
                },
                TypeError,
                `${debug(nonKey)} is not a Property Key`
            );
        });

        t.throws(
            () => {
                ES.Invoke({ o: false }, 'o');
            },
            TypeError,
            'fails on a non-function'
        );

        t.test('invoked callback', st => {
            const aValue = {};
            const bValue = {};
            const obj = {
                f(a) {
                    st.equal(arguments.length, 2, '2 args passed');
                    st.equal(a, aValue, 'first arg is correct');
                    st.equal(arguments[1], bValue, 'second arg is correct');
                },
            };
            st.plan(3);
            ES.Invoke(obj, 'f', aValue, bValue);
        });

        t.end();
    });

    test('CreateIterResultObject', t => {
        forEach(v.nonBooleans, nonBoolean => {
            t.throws(
                () => {
                    ES.CreateIterResultObject({}, nonBoolean);
                },
                TypeError,
                `"done" argument must be a boolean; ${debug(nonBoolean)} is not`
            );
        });

        const value = {};
        t.deepEqual(
            ES.CreateIterResultObject(value, true),
            {
                value,
                done: true,
            },
            'creates a "done" iteration result'
        );
        t.deepEqual(
            ES.CreateIterResultObject(value, false),
            {
                value,
                done: false,
            },
            'creates a "not done" iteration result'
        );

        t.end();
    });

    test('RegExpExec', t => {
        forEach(v.primitives, primitive => {
            t.throws(
                () => {
                    ES.RegExpExec(primitive);
                },
                TypeError,
                `"R" argument must be an object; ${debug(primitive)} is not`
            );
        });

        forEach(v.nonStrings, nonString => {
            t.throws(
                () => {
                    ES.RegExpExec({}, nonString);
                },
                TypeError,
                `"S" argument must be a String; ${debug(nonString)} is not`
            );
        });

        t.test('gets and calls a callable "exec"', st => {
            const str = '123';
            var o = {
                exec(S) {
                    st.equal(this, o, '"exec" receiver is R');
                    st.equal(S, str, '"exec" argument is S');

                    return null;
                },
            };
            st.plan(2);
            ES.RegExpExec(o, str);
            st.end();
        });

        t.test(
            'throws if a callable "exec" returns a non-null non-object',
            st => {
                const str = '123';
                st.plan(v.nonNullPrimitives.length);
                forEach(v.nonNullPrimitives, nonNullPrimitive => {
                    st.throws(
                        () => {
                            ES.RegExpExec(
                                {
                                    exec() {
                                        return nonNullPrimitive;
                                    },
                                },
                                str
                            );
                        },
                        TypeError,
                        `"exec" method must return \`null\` or an Object; ${debug(
                            nonNullPrimitive
                        )} is not`
                    );
                });
                st.end();
            }
        );

        t.test('actual regex that should match against a string', st => {
            const S = 'aabc';
            const R = /a/g;
            const match1 = ES.RegExpExec(R, S);
            const match2 = ES.RegExpExec(R, S);
            const match3 = ES.RegExpExec(R, S);
            st.deepEqual(
                match1,
                assign(['a'], { index: 0, input: S }),
                'match object 1 is as expected'
            );
            st.deepEqual(
                match2,
                assign(['a'], { index: 1, input: S }),
                'match object 2 is as expected'
            );
            st.equal(match3, null, 'match 3 is null as expected');
            st.end();
        });

        t.test(
            'actual regex that should match against a string, with shadowed "exec"',
            st => {
                const S = 'aabc';
                const R = /a/g;
                R.exec = undefined;
                const match1 = ES.RegExpExec(R, S);
                const match2 = ES.RegExpExec(R, S);
                const match3 = ES.RegExpExec(R, S);
                st.deepEqual(
                    match1,
                    assign(['a'], { index: 0, input: S }),
                    'match object 1 is as expected'
                );
                st.deepEqual(
                    match2,
                    assign(['a'], { index: 1, input: S }),
                    'match object 2 is as expected'
                );
                st.equal(match3, null, 'match 3 is null as expected');
                st.end();
            }
        );
        t.end();
    });

    test('ArraySpeciesCreate', t => {
        t.test('errors', st => {
            const testNonNumber = function(nonNumber) {
                st.throws(
                    () => {
                        ES.ArraySpeciesCreate([], nonNumber);
                    },
                    TypeError,
                    `${debug(nonNumber)} is not a number`
                );
            };
            forEach(v.nonNumbers, testNonNumber);

            st.throws(
                () => {
                    ES.ArraySpeciesCreate([], -1);
                },
                TypeError,
                '-1 is not >= 0'
            );
            st.throws(
                () => {
                    ES.ArraySpeciesCreate([], -Infinity);
                },
                TypeError,
                '-Infinity is not >= 0'
            );

            const testNonIntegers = function(nonInteger) {
                st.throws(
                    () => {
                        ES.ArraySpeciesCreate([], nonInteger);
                    },
                    TypeError,
                    `${debug(nonInteger)} is not an integer`
                );
            };
            forEach(v.nonIntegerNumbers, testNonIntegers);

            st.end();
        });

        t.test('works with a non-array', st => {
            forEach(v.objects.concat(v.primitives), nonArray => {
                const arr = ES.ArraySpeciesCreate(nonArray, 0);
                st.ok(ES.IsArray(arr), 'is an array');
                st.equal(arr.length, 0, 'length is correct');
                st.equal(arr.constructor, Array, 'constructor is correct');
            });

            st.end();
        });

        t.test('works with a normal array', st => {
            const len = 2;
            const orig = [1, 2, 3];
            const arr = ES.ArraySpeciesCreate(orig, len);

            st.ok(ES.IsArray(arr), 'is an array');
            st.equal(arr.length, len, 'length is correct');
            st.equal(
                arr.constructor,
                orig.constructor,
                'constructor is correct'
            );

            st.end();
        });

        t.test('-0 length produces +0 length', st => {
            const len = -0;
            st.ok(is(len, -0), '-0 is negative zero');
            st.notOk(is(len, 0), '-0 is not positive zero');

            const orig = [1, 2, 3];
            const arr = ES.ArraySpeciesCreate(orig, len);

            st.equal(ES.IsArray(arr), true);
            st.ok(is(arr.length, 0));
            st.equal(arr.constructor, orig.constructor);

            st.end();
        });

        t.test('works with species construtor', { skip: !hasSpecies }, st => {
            const sentinel = {};
            const Foo = function Foo(len) {
                this.length = len;
                this.sentinel = sentinel;
            };
            const Bar = getArraySubclassWithSpeciesConstructor(Foo);
            const bar = new Bar();

            t.equal(ES.IsArray(bar), true, 'Bar instance is an array');

            const arr = ES.ArraySpeciesCreate(bar, 3);
            st.equal(arr.constructor, Foo, 'result used species constructor');
            st.equal(arr.length, 3, 'length property is correct');
            st.equal(arr.sentinel, sentinel, 'Foo constructor was exercised');

            st.end();
        });

        t.test(
            'works with null species constructor',
            { skip: !hasSpecies },
            st => {
                const Bar = getArraySubclassWithSpeciesConstructor(null);
                const bar = new Bar();

                t.equal(ES.IsArray(bar), true, 'Bar instance is an array');

                const arr = ES.ArraySpeciesCreate(bar, 3);
                st.equal(
                    arr.constructor,
                    Array,
                    'result used default constructor'
                );
                st.equal(arr.length, 3, 'length property is correct');

                st.end();
            }
        );

        t.test(
            'works with undefined species constructor',
            { skip: !hasSpecies },
            st => {
                const Bar = getArraySubclassWithSpeciesConstructor();
                const bar = new Bar();

                t.equal(ES.IsArray(bar), true, 'Bar instance is an array');

                const arr = ES.ArraySpeciesCreate(bar, 3);
                st.equal(
                    arr.constructor,
                    Array,
                    'result used default constructor'
                );
                st.equal(arr.length, 3, 'length property is correct');

                st.end();
            }
        );

        t.test(
            'throws with object non-construtor species constructor',
            { skip: !hasSpecies },
            st => {
                forEach(v.objects, obj => {
                    const Bar = getArraySubclassWithSpeciesConstructor(obj);
                    const bar = new Bar();

                    st.equal(ES.IsArray(bar), true, 'Bar instance is an array');

                    st.throws(
                        () => {
                            ES.ArraySpeciesCreate(bar, 3);
                        },
                        TypeError,
                        `${debug(obj)} is not a constructor`
                    );
                });

                st.end();
            }
        );

        t.end();
    });

    test('CreateDataProperty', t => {
        forEach(v.primitives, primitive => {
            t.throws(
                () => {
                    ES.CreateDataProperty(primitive);
                },
                TypeError,
                `${debug(primitive)} is not an object`
            );
        });

        forEach(v.nonPropertyKeys, nonPropertyKey => {
            t.throws(
                () => {
                    ES.CreateDataProperty({}, nonPropertyKey);
                },
                TypeError,
                `${debug(nonPropertyKey)} is not a property key`
            );
        });

        const sentinel = {};
        forEach(v.propertyKeys, propertyKey => {
            const obj = {};
            const status = ES.CreateDataProperty(obj, propertyKey, sentinel);
            t.equal(status, true, 'status is true');
            t.equal(
                obj[propertyKey],
                sentinel,
                `${debug(sentinel)} is installed on "${debug(
                    propertyKey
                )}" on the object`
            );

            if (typeof Object.defineProperty === 'function') {
                const nonWritable = Object.defineProperty({}, propertyKey, {
                    configurable: true,
                    writable: false,
                });

                const nonWritableStatus = ES.CreateDataProperty(
                    nonWritable,
                    propertyKey,
                    sentinel
                );
                t.equal(
                    nonWritableStatus,
                    false,
                    'create data property failed'
                );
                t.notEqual(
                    nonWritable[propertyKey],
                    sentinel,
                    `${debug(sentinel)} is not installed on "${debug(
                        propertyKey
                    )}" on the object when key is nonwritable`
                );

                const nonConfigurable = Object.defineProperty({}, propertyKey, {
                    configurable: false,
                    writable: true,
                });

                const nonConfigurableStatus = ES.CreateDataProperty(
                    nonConfigurable,
                    propertyKey,
                    sentinel
                );
                t.equal(
                    nonConfigurableStatus,
                    false,
                    'create data property failed'
                );
                t.notEqual(
                    nonConfigurable[propertyKey],
                    sentinel,
                    `${debug(sentinel)} is not installed on "${debug(
                        propertyKey
                    )}" on the object when key is nonconfigurable`
                );
            }
        });

        t.end();
    });

    test('CreateDataPropertyOrThrow', t => {
        forEach(v.primitives, primitive => {
            t.throws(
                () => {
                    ES.CreateDataPropertyOrThrow(primitive);
                },
                TypeError,
                `${debug(primitive)} is not an object`
            );
        });

        forEach(v.nonPropertyKeys, nonPropertyKey => {
            t.throws(
                () => {
                    ES.CreateDataPropertyOrThrow({}, nonPropertyKey);
                },
                TypeError,
                `${debug(nonPropertyKey)} is not a property key`
            );
        });

        const sentinel = {};
        forEach(v.propertyKeys, propertyKey => {
            const obj = {};
            const status = ES.CreateDataPropertyOrThrow(
                obj,
                propertyKey,
                sentinel
            );
            t.equal(status, true, 'status is true');
            t.equal(
                obj[propertyKey],
                sentinel,
                `${debug(sentinel)} is installed on "${debug(
                    propertyKey
                )}" on the object`
            );

            if (typeof Object.preventExtensions === 'function') {
                const notExtensible = {};
                Object.preventExtensions(notExtensible);

                t.throws(
                    () => {
                        ES.CreateDataPropertyOrThrow(
                            notExtensible,
                            propertyKey,
                            sentinel
                        );
                    },
                    TypeError,
                    `can not install ${debug(
                        propertyKey
                    )} on non-extensible object`
                );
                t.notEqual(
                    notExtensible[propertyKey],
                    sentinel,
                    `${debug(sentinel)} is not installed on "${debug(
                        propertyKey
                    )}" on the object`
                );
            }
        });

        t.end();
    });

    test('AdvanceStringIndex', t => {
        forEach(v.nonStrings, nonString => {
            t.throws(
                () => {
                    ES.AdvanceStringIndex(nonString);
                },
                TypeError,
                `"S" argument must be a String; ${debug(nonString)} is not`
            );
        });

        forEach(v.nonIntegerNumbers, nonInteger => {
            t.throws(
                () => {
                    ES.AdvanceStringIndex('', nonInteger, false);
                },
                TypeError,
                `"index" argument must be an integer; ${debug(
                    nonInteger
                )} is not`
            );
        });
        forEach([-1, -42], negative => {
            t.throws(
                () => {
                    ES.AdvanceStringIndex('', negative, false);
                },
                RangeError,
                `"index" argument must be a non-negative integer; ${debug(
                    negative
                )} is not`
            );
        });
        t.throws(
            () => {
                ES.AdvanceStringIndex('', MAX_SAFE_INTEGER + 1, false);
            },
            RangeError,
            'too large integers throw'
        );

        forEach(v.nonBooleans, nonBoolean => {
            t.throws(
                () => {
                    ES.AdvanceStringIndex('', 0, nonBoolean);
                },
                TypeError,
                `"unicode" argument must be a Boolean; ${debug(
                    nonBoolean
                )} is not`
            );
        });

        t.test('when unicode is false', st => {
            st.equal(
                ES.AdvanceStringIndex('', 0, false),
                1,
                'index is incremented by 1'
            );
            st.equal(
                ES.AdvanceStringIndex('abc', 0, false),
                1,
                'index is incremented by 1'
            );
            st.equal(
                ES.AdvanceStringIndex('', 3, false),
                4,
                'index is incremented by 1'
            );
            st.equal(
                ES.AdvanceStringIndex('abc', 3, false),
                4,
                'index is incremented by 1'
            );

            st.test('when the index is within the string', s2t => {
                s2t.equal(ES.AdvanceStringIndex('abc', 0, false), 1, '0 -> 1');
                s2t.equal(ES.AdvanceStringIndex('abc', 1, false), 2, '1 -> 2');
                s2t.equal(ES.AdvanceStringIndex('abc', 2, false), 3, '2 -> 3');
                s2t.end();
            });

            st.end();
        });

        t.test('when unicode is true', st => {
            st.test('when index + 1 >= length', s2t => {
                t.equal(
                    ES.AdvanceStringIndex('', 0, true),
                    1,
                    'index is incremented by 1'
                );
                t.equal(
                    ES.AdvanceStringIndex('a', 0, true),
                    1,
                    'index is incremented by 1'
                );
                t.equal(
                    ES.AdvanceStringIndex('a', 5, true),
                    6,
                    'index is incremented by 1'
                );
                s2t.end();
            });

            st.test('when the index is within the string', s2t => {
                s2t.equal(ES.AdvanceStringIndex('abc', 0, true), 1, '0 -> 1');
                s2t.equal(ES.AdvanceStringIndex('abc', 1, true), 2, '1 -> 2');
                s2t.equal(ES.AdvanceStringIndex('abc', 2, true), 3, '2 -> 3');
                s2t.end();
            });

            st.test('surrogate pairs', s2t => {
                const lowestPair =
                    String.fromCharCode('0xD800') +
                    String.fromCharCode('0xDC00');
                const highestPair =
                    String.fromCharCode('0xDBFF') +
                    String.fromCharCode('0xDFFF');
                const poop =
                    String.fromCharCode('0xD83D') +
                    String.fromCharCode('0xDCA9');
                s2t.equal(
                    ES.AdvanceStringIndex(lowestPair, 0, true),
                    2,
                    'lowest surrogate pair, 0 -> 2'
                );
                s2t.equal(
                    ES.AdvanceStringIndex(highestPair, 0, true),
                    2,
                    'highest surrogate pair, 0 -> 2'
                );
                s2t.equal(
                    ES.AdvanceStringIndex(poop, 0, true),
                    2,
                    'poop, 0 -> 2'
                );
                s2t.end();
            });

            st.end();
        });

        t.end();
    });
};

const es2016 = function ES2016(ES, ops, expectedMissing) {
    es2015(ES, ops, expectedMissing);

    test('SameValueNonNumber', t => {
        const willThrow = [
            [3, 4],
            [NaN, 4],
            [4, ''],
            ['abc', true],
            [{}, false],
        ];
        forEach(willThrow, nums => {
            t.throws(
                () => ES.SameValueNonNumber(...nums),
                TypeError,
                'value must be same type and non-number'
            );
        });

        forEach(v.objects.concat(v.nonNumberPrimitives), val => {
            t.equal(
                val === val,
                ES.SameValueNonNumber(val, val),
                `${debug(val)} is SameValueNonNumber to itself`
            );
        });

        t.end();
    });
};

const es2017 = function E2017(ES, ops, expectedMissing) {
    es2016(ES, ops, expectedMissing);

    test('ToIndex', t => {
        t.ok(is(ES.ToIndex(), 0), 'no value gives 0');
        t.ok(is(ES.ToIndex(undefined), 0), 'undefined value gives 0');

        t.throws(
            () => {
                ES.ToIndex(-1);
            },
            RangeError,
            'negative numbers throw'
        );

        t.throws(
            () => {
                ES.ToIndex(MAX_SAFE_INTEGER + 1);
            },
            RangeError,
            'too large numbers throw'
        );

        t.equal(ES.ToIndex(3), 3, 'numbers work');
        t.equal(
            ES.ToIndex(v.valueOfOnlyObject),
            4,
            'coercible objects are coerced'
        );

        t.end();
    });
};

module.exports = {
    es2015,
    es2016,
    es2017,
};
