'use strict';

const ES = require('../').ES5;
const test = require('tape');

const forEach = require('foreach');
const is = require('object-is');

const coercibleObject = {
    valueOf() {
        return '3';
    },
    toString() {
        return 42;
    },
};
const coercibleFnObject = {
    valueOf() {
        return function valueOfFn() {};
    },
    toString() {
        return 42;
    },
};
const valueOfOnlyObject = {
    valueOf() {
        return 4;
    },
    toString() {
        return {};
    },
};
const toStringOnlyObject = {
    valueOf() {
        return {};
    },
    toString() {
        return 7;
    },
};
const uncoercibleObject = {
    valueOf() {
        return {};
    },
    toString() {
        return {};
    },
};
const uncoercibleFnObject = {
    valueOf() {
        return function valueOfFn() {};
    },
    toString() {
        return function toStrFn() {};
    },
};
const objects = [{}, coercibleObject, toStringOnlyObject, valueOfOnlyObject];
const numbers = [0, -0, Infinity, -Infinity, 42];
const nonNullPrimitives = [true, false, 'foo', ''].concat(numbers);
const primitives = [undefined, null].concat(nonNullPrimitives);

test('ToPrimitive', t => {
    t.test('primitives', st => {
        const testPrimitive = function(primitive) {
            st.ok(
                is(ES.ToPrimitive(primitive), primitive),
                `${primitive} is returned correctly`
            );
        };
        forEach(primitives, testPrimitive);
        st.end();
    });

    t.test('objects', st => {
        st.equal(
            ES.ToPrimitive(coercibleObject),
            coercibleObject.valueOf(),
            'coercibleObject coerces to valueOf'
        );
        st.equal(
            ES.ToPrimitive(coercibleObject, Number),
            coercibleObject.valueOf(),
            'coercibleObject with hint Number coerces to valueOf'
        );
        st.equal(
            ES.ToPrimitive(coercibleObject, String),
            coercibleObject.toString(),
            'coercibleObject with hint String coerces to toString'
        );
        st.equal(
            ES.ToPrimitive(coercibleFnObject),
            coercibleFnObject.toString(),
            'coercibleFnObject coerces to toString'
        );
        st.equal(
            ES.ToPrimitive(toStringOnlyObject),
            toStringOnlyObject.toString(),
            'toStringOnlyObject returns toString'
        );
        st.equal(
            ES.ToPrimitive(valueOfOnlyObject),
            valueOfOnlyObject.valueOf(),
            'valueOfOnlyObject returns valueOf'
        );
        st.equal(
            ES.ToPrimitive({}),
            '[object Object]',
            '{} with no hint coerces to Object#toString'
        );
        st.equal(
            ES.ToPrimitive({}, String),
            '[object Object]',
            '{} with hint String coerces to Object#toString'
        );
        st.equal(
            ES.ToPrimitive({}, Number),
            '[object Object]',
            '{} with hint Number coerces to Object#toString'
        );
        st.throws(
            () => ES.ToPrimitive(uncoercibleObject),
            TypeError,
            'uncoercibleObject throws a TypeError'
        );
        st.throws(
            () => ES.ToPrimitive(uncoercibleFnObject),
            TypeError,
            'uncoercibleFnObject throws a TypeError'
        );
        st.end();
    });

    t.end();
});

test('ToBoolean', t => {
    t.equal(false, ES.ToBoolean(undefined), 'undefined coerces to false');
    t.equal(false, ES.ToBoolean(null), 'null coerces to false');
    t.equal(false, ES.ToBoolean(false), 'false returns false');
    t.equal(true, ES.ToBoolean(true), 'true returns true');
    forEach([0, -0, NaN], falsyNumber => {
        t.equal(
            false,
            ES.ToBoolean(falsyNumber),
            `falsy number ${falsyNumber} coerces to false`
        );
    });
    forEach([Infinity, 42, 1, -Infinity], truthyNumber => {
        t.equal(
            true,
            ES.ToBoolean(truthyNumber),
            `truthy number ${truthyNumber} coerces to true`
        );
    });
    t.equal(false, ES.ToBoolean(''), 'empty string coerces to false');
    t.equal(true, ES.ToBoolean('foo'), 'nonempty string coerces to true');
    forEach(objects, obj => {
        t.equal(true, ES.ToBoolean(obj), 'object coerces to true');
    });
    t.equal(
        true,
        ES.ToBoolean(uncoercibleObject),
        'uncoercibleObject coerces to true'
    );
    t.end();
});

test('ToNumber', t => {
    t.ok(is(NaN, ES.ToNumber(undefined)), 'undefined coerces to NaN');
    t.ok(is(ES.ToNumber(null), 0), 'null coerces to +0');
    t.ok(is(ES.ToNumber(false), 0), 'false coerces to +0');
    t.equal(1, ES.ToNumber(true), 'true coerces to 1');
    t.ok(is(NaN, ES.ToNumber(NaN)), 'NaN returns itself');
    forEach([0, -0, 42, Infinity, -Infinity], num => {
        t.equal(num, ES.ToNumber(num), `${num} returns itself`);
    });
    forEach(['foo', '0', '4a', '2.0', 'Infinity', '-Infinity'], numString => {
        t.ok(
            is(+numString, ES.ToNumber(numString)),
            `"${numString}" coerces to ${Number(numString)}`
        );
    });
    forEach(objects, object => {
        t.ok(
            is(ES.ToNumber(object), ES.ToNumber(ES.ToPrimitive(object))),
            `object ${object} coerces to same as ToPrimitive of object does`
        );
    });
    t.throws(
        () => ES.ToNumber(uncoercibleObject),
        TypeError,
        'uncoercibleObject throws'
    );
    t.end();
});

test('ToInteger', t => {
    t.ok(is(0, ES.ToInteger(NaN)), 'NaN coerces to +0');
    forEach([0, Infinity, 42], num => {
        t.ok(is(num, ES.ToInteger(num)), `${num} returns itself`);
        t.ok(is(-num, ES.ToInteger(-num)), `-${num} returns itself`);
    });
    t.equal(3, ES.ToInteger(Math.PI), 'pi returns 3');
    t.throws(
        () => ES.ToInteger(uncoercibleObject),
        TypeError,
        'uncoercibleObject throws'
    );
    t.end();
});

test('ToInt32', t => {
    t.ok(is(0, ES.ToInt32(NaN)), 'NaN coerces to +0');
    forEach([0, Infinity], num => {
        t.ok(is(0, ES.ToInt32(num)), `${num} returns +0`);
        t.ok(is(0, ES.ToInt32(-num)), `-${num} returns +0`);
    });
    t.throws(
        () => ES.ToInt32(uncoercibleObject),
        TypeError,
        'uncoercibleObject throws'
    );
    t.ok(is(ES.ToInt32(0x100000000), 0), '2^32 returns +0');
    t.ok(is(ES.ToInt32(0x100000000 - 1), -1), '2^32 - 1 returns -1');
    t.ok(is(ES.ToInt32(0x80000000), -0x80000000), '2^31 returns -2^31');
    t.ok(
        is(ES.ToInt32(0x80000000 - 1), 0x80000000 - 1),
        '2^31 - 1 returns 2^31 - 1'
    );
    forEach([0, Infinity, NaN, 0x100000000, 0x80000000, 0x10000, 0x42], num => {
        t.ok(
            is(ES.ToInt32(num), ES.ToInt32(ES.ToUint32(num))),
            `ToInt32(x) === ToInt32(ToUint32(x)) for 0x${num.toString(16)}`
        );
        t.ok(
            is(ES.ToInt32(-num), ES.ToInt32(ES.ToUint32(-num))),
            `ToInt32(x) === ToInt32(ToUint32(x)) for -0x${num.toString(16)}`
        );
    });
    t.end();
});

test('ToUint32', t => {
    t.ok(is(0, ES.ToUint32(NaN)), 'NaN coerces to +0');
    forEach([0, Infinity], num => {
        t.ok(is(0, ES.ToUint32(num)), `${num} returns +0`);
        t.ok(is(0, ES.ToUint32(-num)), `-${num} returns +0`);
    });
    t.throws(
        () => ES.ToUint32(uncoercibleObject),
        TypeError,
        'uncoercibleObject throws'
    );
    t.ok(is(ES.ToUint32(0x100000000), 0), '2^32 returns +0');
    t.ok(
        is(ES.ToUint32(0x100000000 - 1), 0x100000000 - 1),
        '2^32 - 1 returns 2^32 - 1'
    );
    t.ok(is(ES.ToUint32(0x80000000), 0x80000000), '2^31 returns 2^31');
    t.ok(
        is(ES.ToUint32(0x80000000 - 1), 0x80000000 - 1),
        '2^31 - 1 returns 2^31 - 1'
    );
    forEach([0, Infinity, NaN, 0x100000000, 0x80000000, 0x10000, 0x42], num => {
        t.ok(
            is(ES.ToUint32(num), ES.ToUint32(ES.ToInt32(num))),
            `ToUint32(x) === ToUint32(ToInt32(x)) for 0x${num.toString(16)}`
        );
        t.ok(
            is(ES.ToUint32(-num), ES.ToUint32(ES.ToInt32(-num))),
            `ToUint32(x) === ToUint32(ToInt32(x)) for -0x${num.toString(16)}`
        );
    });
    t.end();
});

test('ToUint16', t => {
    t.ok(is(0, ES.ToUint16(NaN)), 'NaN coerces to +0');
    forEach([0, Infinity], num => {
        t.ok(is(0, ES.ToUint16(num)), `${num} returns +0`);
        t.ok(is(0, ES.ToUint16(-num)), `-${num} returns +0`);
    });
    t.throws(
        () => ES.ToUint16(uncoercibleObject),
        TypeError,
        'uncoercibleObject throws'
    );
    t.ok(is(ES.ToUint16(0x100000000), 0), '2^32 returns +0');
    t.ok(
        is(ES.ToUint16(0x100000000 - 1), 0x10000 - 1),
        '2^32 - 1 returns 2^16 - 1'
    );
    t.ok(is(ES.ToUint16(0x80000000), 0), '2^31 returns +0');
    t.ok(
        is(ES.ToUint16(0x80000000 - 1), 0x10000 - 1),
        '2^31 - 1 returns 2^16 - 1'
    );
    t.ok(is(ES.ToUint16(0x10000), 0), '2^16 returns +0');
    t.ok(
        is(ES.ToUint16(0x10000 - 1), 0x10000 - 1),
        '2^16 - 1 returns 2^16 - 1'
    );
    t.end();
});

test('ToString', t => {
    t.throws(
        () => ES.ToString(uncoercibleObject),
        TypeError,
        'uncoercibleObject throws'
    );
    t.end();
});

test('ToObject', t => {
    t.throws(() => ES.ToObject(undefined), TypeError, 'undefined throws');
    t.throws(() => ES.ToObject(null), TypeError, 'null throws');
    forEach(numbers, number => {
        const obj = ES.ToObject(number);
        t.equal(typeof obj, 'object', `number ${number} coerces to object`);
        t.equal(
            true,
            obj instanceof Number,
            `object of ${number} is Number object`
        );
        t.ok(
            is(obj.valueOf(), number),
            `object of ${number} coerces to ${number}`
        );
    });
    t.end();
});

test('CheckObjectCoercible', t => {
    t.throws(
        () => ES.CheckObjectCoercible(undefined),
        TypeError,
        'undefined throws'
    );
    t.throws(() => ES.CheckObjectCoercible(null), TypeError, 'null throws');
    const checkCoercible = function(value) {
        t.doesNotThrow(
            () => ES.CheckObjectCoercible(value),
            `"${value}" does not throw`
        );
    };
    forEach(objects.concat(nonNullPrimitives), checkCoercible);
    t.end();
});

test('IsCallable', t => {
    t.equal(true, ES.IsCallable(() => {}), 'function is callable');
    const nonCallables = [/a/g, {}, Object.prototype, NaN].concat(primitives);
    forEach(nonCallables, nonCallable => {
        t.equal(
            false,
            ES.IsCallable(nonCallable),
            `${nonCallable} is not callable`
        );
    });
    t.end();
});

test('SameValue', t => {
    t.equal(true, ES.SameValue(NaN, NaN), 'NaN is SameValue as NaN');
    t.equal(false, ES.SameValue(0, -0), '+0 is not SameValue as -0');
    forEach(objects.concat(primitives), val => {
        t.equal(
            val === val,
            ES.SameValue(val, val),
            `"${val}" is SameValue to itself`
        );
    });
    t.end();
});

test('Type', t => {
    t.equal(ES.Type(), 'Undefined', 'Type() is Undefined');
    t.equal(ES.Type(undefined), 'Undefined', 'Type(undefined) is Undefined');
    t.equal(ES.Type(null), 'Null', 'Type(null) is Null');
    t.equal(ES.Type(true), 'Boolean', 'Type(true) is Boolean');
    t.equal(ES.Type(false), 'Boolean', 'Type(false) is Boolean');
    t.equal(ES.Type(0), 'Number', 'Type(0) is Number');
    t.equal(ES.Type(NaN), 'Number', 'Type(NaN) is Number');
    t.equal(ES.Type('abc'), 'String', 'Type("abc") is String');
    t.equal(ES.Type(() => {}), 'Object', 'Type(function () {}) is Object');
    t.equal(ES.Type({}), 'Object', 'Type({}) is Object');
    t.end();
});

const bothDescriptor = function() {
    return { '[[Get]]'() {}, '[[Value]]': true };
};
const accessorDescriptor = function() {
    return {
        '[[Get]]'() {},
        '[[Enumerable]]': true,
        '[[Configurable]]': true,
    };
};
const mutatorDescriptor = function() {
    return {
        '[[Set]]'() {},
        '[[Enumerable]]': true,
        '[[Configurable]]': true,
    };
};
const dataDescriptor = function() {
    return {
        '[[Value]]': 42,
        '[[Writable]]': false,
        '[[Configurable]]': false,
    };
};
const genericDescriptor = function() {
    return {
        '[[Configurable]]': true,
        '[[Enumerable]]': false,
    };
};

test('IsPropertyDescriptor', t => {
    forEach(primitives, primitive => {
        t.equal(
            ES.IsPropertyDescriptor(primitive),
            false,
            `${primitive} is not a Property Descriptor`
        );
    });

    t.equal(
        ES.IsPropertyDescriptor({ invalid: true }),
        false,
        'invalid keys not allowed on a Property Descriptor'
    );

    t.equal(
        ES.IsPropertyDescriptor({}),
        true,
        'empty object is an incomplete Property Descriptor'
    );

    t.equal(
        ES.IsPropertyDescriptor(accessorDescriptor()),
        true,
        'accessor descriptor is a Property Descriptor'
    );
    t.equal(
        ES.IsPropertyDescriptor(mutatorDescriptor()),
        true,
        'mutator descriptor is a Property Descriptor'
    );
    t.equal(
        ES.IsPropertyDescriptor(dataDescriptor()),
        true,
        'data descriptor is a Property Descriptor'
    );
    t.equal(
        ES.IsPropertyDescriptor(genericDescriptor()),
        true,
        'generic descriptor is a Property Descriptor'
    );

    t.throws(
        () => {
            ES.IsPropertyDescriptor(bothDescriptor());
        },
        TypeError,
        'a Property Descriptor can not be both a Data and an Accessor Descriptor'
    );

    t.end();
});

test('IsAccessorDescriptor', t => {
    forEach(nonNullPrimitives.concat(null), primitive => {
        t.throws(
            () => {
                ES.IsAccessorDescriptor(primitive);
            },
            TypeError,
            `${primitive} is not a Property Descriptor`
        );
    });

    t.equal(
        ES.IsAccessorDescriptor(),
        false,
        'no value is not an Accessor Descriptor'
    );
    t.equal(
        ES.IsAccessorDescriptor(undefined),
        false,
        'undefined value is not an Accessor Descriptor'
    );

    t.equal(
        ES.IsAccessorDescriptor(accessorDescriptor()),
        true,
        'accessor descriptor is an Accessor Descriptor'
    );
    t.equal(
        ES.IsAccessorDescriptor(mutatorDescriptor()),
        true,
        'mutator descriptor is an Accessor Descriptor'
    );
    t.equal(
        ES.IsAccessorDescriptor(dataDescriptor()),
        false,
        'data descriptor is not an Accessor Descriptor'
    );
    t.equal(
        ES.IsAccessorDescriptor(genericDescriptor()),
        false,
        'generic descriptor is not an Accessor Descriptor'
    );

    t.end();
});

test('IsDataDescriptor', t => {
    forEach(nonNullPrimitives.concat(null), primitive => {
        t.throws(
            () => {
                ES.IsDataDescriptor(primitive);
            },
            TypeError,
            `${primitive} is not a Property Descriptor`
        );
    });

    t.equal(ES.IsDataDescriptor(), false, 'no value is not a Data Descriptor');
    t.equal(
        ES.IsDataDescriptor(undefined),
        false,
        'undefined value is not a Data Descriptor'
    );

    t.equal(
        ES.IsDataDescriptor(accessorDescriptor()),
        false,
        'accessor descriptor is not a Data Descriptor'
    );
    t.equal(
        ES.IsDataDescriptor(mutatorDescriptor()),
        false,
        'mutator descriptor is not a Data Descriptor'
    );
    t.equal(
        ES.IsDataDescriptor(dataDescriptor()),
        true,
        'data descriptor is a Data Descriptor'
    );
    t.equal(
        ES.IsDataDescriptor(genericDescriptor()),
        false,
        'generic descriptor is not a Data Descriptor'
    );

    t.end();
});

test('IsGenericDescriptor', t => {
    forEach(nonNullPrimitives.concat(null), primitive => {
        t.throws(
            () => {
                ES.IsGenericDescriptor(primitive);
            },
            TypeError,
            `${primitive} is not a Property Descriptor`
        );
    });

    t.equal(
        ES.IsGenericDescriptor(),
        false,
        'no value is not a Data Descriptor'
    );
    t.equal(
        ES.IsGenericDescriptor(undefined),
        false,
        'undefined value is not a Data Descriptor'
    );

    t.equal(
        ES.IsGenericDescriptor(accessorDescriptor()),
        false,
        'accessor descriptor is not a generic Descriptor'
    );
    t.equal(
        ES.IsGenericDescriptor(mutatorDescriptor()),
        false,
        'mutator descriptor is not a generic Descriptor'
    );
    t.equal(
        ES.IsGenericDescriptor(dataDescriptor()),
        false,
        'data descriptor is not a generic Descriptor'
    );

    t.equal(
        ES.IsGenericDescriptor(genericDescriptor()),
        true,
        'generic descriptor is a generic Descriptor'
    );

    t.end();
});

test('FromPropertyDescriptor', t => {
    t.equal(
        ES.FromPropertyDescriptor(),
        undefined,
        'no value begets undefined'
    );
    t.equal(
        ES.FromPropertyDescriptor(undefined),
        undefined,
        'undefined value begets undefined'
    );

    forEach(nonNullPrimitives.concat(null), primitive => {
        t.throws(
            () => {
                ES.FromPropertyDescriptor(primitive);
            },
            TypeError,
            `${primitive} is not a Property Descriptor`
        );
    });

    const accessor = accessorDescriptor();
    t.deepEqual(ES.FromPropertyDescriptor(accessor), {
        get: accessor['[[Get]]'],
        set: accessor['[[Set]]'],
        enumerable: !!accessor['[[Enumerable]]'],
        configurable: !!accessor['[[Configurable]]'],
    });

    const mutator = mutatorDescriptor();
    t.deepEqual(ES.FromPropertyDescriptor(mutator), {
        get: mutator['[[Get]]'],
        set: mutator['[[Set]]'],
        enumerable: !!mutator['[[Enumerable]]'],
        configurable: !!mutator['[[Configurable]]'],
    });
    const data = dataDescriptor();
    t.deepEqual(ES.FromPropertyDescriptor(data), {
        value: data['[[Value]]'],
        writable: data['[[Writable]]'],
        enumerable: !!data['[[Enumerable]]'],
        configurable: !!data['[[Configurable]]'],
    });

    t.throws(
        () => {
            ES.FromPropertyDescriptor(genericDescriptor());
        },
        TypeError,
        'a complete Property Descriptor is required'
    );

    t.end();
});

test('ToPropertyDescriptor', t => {
    forEach(nonNullPrimitives.concat(null), primitive => {
        t.throws(
            () => {
                ES.ToPropertyDescriptor(primitive);
            },
            TypeError,
            `${primitive} is not an Object`
        );
    });

    const accessor = accessorDescriptor();
    t.deepEqual(
        ES.ToPropertyDescriptor({
            get: accessor['[[Get]]'],
            enumerable: !!accessor['[[Enumerable]]'],
            configurable: !!accessor['[[Configurable]]'],
        }),
        accessor
    );

    const mutator = mutatorDescriptor();
    t.deepEqual(
        ES.ToPropertyDescriptor({
            set: mutator['[[Set]]'],
            enumerable: !!mutator['[[Enumerable]]'],
            configurable: !!mutator['[[Configurable]]'],
        }),
        mutator
    );

    const data = dataDescriptor();
    t.deepEqual(
        ES.ToPropertyDescriptor({
            value: data['[[Value]]'],
            writable: data['[[Writable]]'],
            configurable: !!data['[[Configurable]]'],
        }),
        data
    );

    const both = bothDescriptor();
    t.throws(
        () => {
            ES.ToPropertyDescriptor({
                get: both['[[Get]]'],
                value: both['[[Value]]'],
            });
        },
        TypeError,
        'data and accessor descriptors are mutually exclusive'
    );

    t.throws(
        () => {
            ES.ToPropertyDescriptor({ get: 'not callable' });
        },
        TypeError,
        '"get" must be undefined or callable'
    );

    t.throws(
        () => {
            ES.ToPropertyDescriptor({ set: 'not callable' });
        },
        TypeError,
        '"set" must be undefined or callable'
    );

    t.end();
});
