'use strict';

const hasSymbols =
    typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

const isPrimitive = require('./helpers/isPrimitive');
const isCallable = require('is-callable');
const isDate = require('is-date-object');
const isSymbol = require('is-symbol');

const ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
    if (typeof O === 'undefined' || O === null) {
        throw new TypeError(`Cannot call method on ${O}`);
    }
    if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
        throw new TypeError('hint must be "string" or "number"');
    }
    const methodNames =
        hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
    let method, result, i;
    for (i = 0; i < methodNames.length; ++i) {
        method = O[methodNames[i]];
        if (isCallable(method)) {
            result = method.call(O);
            if (isPrimitive(result)) {
                return result;
            }
        }
    }
    throw new TypeError('No default value');
};

const GetMethod = function GetMethod(O, P) {
    const func = O[P];
    if (func !== null && typeof func !== 'undefined') {
        if (!isCallable(func)) {
            throw new TypeError(
                `${func} returned for property ${P} of object ${O} is not a function`
            );
        }
        return func;
    }
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input, PreferredType) {
    if (isPrimitive(input)) {
        return input;
    }
    let hint = 'default';
    if (arguments.length > 1) {
        if (PreferredType === String) {
            hint = 'string';
        } else if (PreferredType === Number) {
            hint = 'number';
        }
    }

    let exoticToPrim;
    if (hasSymbols) {
        if (Symbol.toPrimitive) {
            exoticToPrim = GetMethod(input, Symbol.toPrimitive);
        } else if (isSymbol(input)) {
            exoticToPrim = Symbol.prototype.valueOf;
        }
    }
    if (typeof exoticToPrim !== 'undefined') {
        const result = exoticToPrim.call(input, hint);
        if (isPrimitive(result)) {
            return result;
        }
        throw new TypeError('unable to convert exotic object to primitive');
    }
    if (hint === 'default' && (isDate(input) || isSymbol(input))) {
        hint = 'string';
    }
    return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};
