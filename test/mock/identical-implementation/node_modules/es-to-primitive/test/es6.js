'use strict';

const test = require('tape');
const toPrimitive = require('../es6');
const is = require('object-is');
const forEach = require('foreach');
const debug = require('util').inspect;

const hasSymbols =
    typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';
const hasSymbolToPrimitive =
    hasSymbols && typeof Symbol.toPrimitive === 'symbol';

const primitives = [
    null,
    undefined,
    true,
    false,
    0,
    -0,
    42,
    NaN,
    Infinity,
    -Infinity,
    '',
    'abc',
];

test('primitives', t => {
    forEach(primitives, i => {
        t.ok(
            is(toPrimitive(i), i),
            `toPrimitive(${debug(i)}) returns the same value`
        );
        t.ok(
            is(toPrimitive(i, String), i),
            `toPrimitive(${debug(i)}, String) returns the same value`
        );
        t.ok(
            is(toPrimitive(i, Number), i),
            `toPrimitive(${debug(i)}, Number) returns the same value`
        );
    });
    t.end();
});

test('Symbols', { skip: !hasSymbols }, t => {
    const symbols = [Symbol(), Symbol.iterator, Symbol.for('foo')];
    forEach(symbols, sym => {
        t.equal(
            toPrimitive(sym),
            sym,
            `toPrimitive(${debug(sym)}) returns the same value`
        );
        t.equal(
            toPrimitive(sym, String),
            sym,
            `toPrimitive(${debug(sym)}, String) returns the same value`
        );
        t.equal(
            toPrimitive(sym, Number),
            sym,
            `toPrimitive(${debug(sym)}, Number) returns the same value`
        );
    });

    const primitiveSym = Symbol('primitiveSym');
    const objectSym = Object(primitiveSym);
    t.equal(
        toPrimitive(objectSym),
        primitiveSym,
        `toPrimitive(${debug(objectSym)}) returns ${debug(primitiveSym)}`
    );
    t.equal(
        toPrimitive(objectSym, String),
        primitiveSym,
        `toPrimitive(${debug(objectSym)}, String) returns ${debug(
            primitiveSym
        )}`
    );
    t.equal(
        toPrimitive(objectSym, Number),
        primitiveSym,
        `toPrimitive(${debug(objectSym)}, Number) returns ${debug(
            primitiveSym
        )}`
    );
    t.end();
});

test('Arrays', t => {
    const arrays = [[], ['a', 'b'], [1, 2]];
    forEach(arrays, arr => {
        t.equal(
            toPrimitive(arr),
            String(arr),
            `toPrimitive(${debug(arr)}) returns the string version of the array`
        );
        t.equal(
            toPrimitive(arr, String),
            String(arr),
            `toPrimitive(${debug(arr)}) returns the string version of the array`
        );
        t.equal(
            toPrimitive(arr, Number),
            String(arr),
            `toPrimitive(${debug(arr)}) returns the string version of the array`
        );
    });
    t.end();
});

test('Dates', t => {
    const dates = [new Date(), new Date(0), new Date(NaN)];
    forEach(dates, date => {
        t.equal(
            toPrimitive(date),
            String(date),
            `toPrimitive(${debug(date)}) returns the string version of the date`
        );
        t.equal(
            toPrimitive(date, String),
            String(date),
            `toPrimitive(${debug(date)}) returns the string version of the date`
        );
        t.ok(
            is(toPrimitive(date, Number), Number(date)),
            `toPrimitive(${debug(date)}) returns the number version of the date`
        );
    });
    t.end();
});

const coercibleObject = {
    valueOf() {
        return 3;
    },
    toString() {
        return 42;
    },
};
const valueOfOnlyObject = {
    valueOf() {
        return 4;
    },
    toString() {
        return {};
    },
};
const toStringOnlyObject = {
    valueOf() {
        return {};
    },
    toString() {
        return 7;
    },
};
const coercibleFnObject = {
    valueOf() {
        return function valueOfFn() {};
    },
    toString() {
        return 42;
    },
};
const uncoercibleObject = {
    valueOf() {
        return {};
    },
    toString() {
        return {};
    },
};
const uncoercibleFnObject = {
    valueOf() {
        return function valueOfFn() {};
    },
    toString() {
        return function toStrFn() {};
    },
};

test('Objects', t => {
    t.equal(
        toPrimitive(coercibleObject),
        coercibleObject.valueOf(),
        'coercibleObject with no hint coerces to valueOf'
    );
    t.equal(
        toPrimitive(coercibleObject, Number),
        coercibleObject.valueOf(),
        'coercibleObject with hint Number coerces to valueOf'
    );
    t.equal(
        toPrimitive(coercibleObject, String),
        coercibleObject.toString(),
        'coercibleObject with hint String coerces to non-stringified toString'
    );

    t.equal(
        toPrimitive(coercibleFnObject),
        coercibleFnObject.toString(),
        'coercibleFnObject coerces to non-stringified toString'
    );
    t.equal(
        toPrimitive(coercibleFnObject, Number),
        coercibleFnObject.toString(),
        'coercibleFnObject with hint Number coerces to non-stringified toString'
    );
    t.equal(
        toPrimitive(coercibleFnObject, String),
        coercibleFnObject.toString(),
        'coercibleFnObject with hint String coerces to non-stringified toString'
    );

    t.equal(
        toPrimitive({}),
        '[object Object]',
        '{} with no hint coerces to Object#toString'
    );
    t.equal(
        toPrimitive({}, Number),
        '[object Object]',
        '{} with hint Number coerces to Object#toString'
    );
    t.equal(
        toPrimitive({}, String),
        '[object Object]',
        '{} with hint String coerces to Object#toString'
    );

    t.equal(
        toPrimitive(toStringOnlyObject),
        toStringOnlyObject.toString(),
        'toStringOnlyObject returns non-stringified toString'
    );
    t.equal(
        toPrimitive(toStringOnlyObject, Number),
        toStringOnlyObject.toString(),
        'toStringOnlyObject with hint Number returns non-stringified toString'
    );
    t.equal(
        toPrimitive(toStringOnlyObject, String),
        toStringOnlyObject.toString(),
        'toStringOnlyObject with hint String returns non-stringified toString'
    );

    t.equal(
        toPrimitive(valueOfOnlyObject),
        valueOfOnlyObject.valueOf(),
        'valueOfOnlyObject returns valueOf'
    );
    t.equal(
        toPrimitive(valueOfOnlyObject, Number),
        valueOfOnlyObject.valueOf(),
        'valueOfOnlyObject with hint Number returns valueOf'
    );
    t.equal(
        toPrimitive(valueOfOnlyObject, String),
        valueOfOnlyObject.valueOf(),
        'valueOfOnlyObject with hint String returns non-stringified valueOf'
    );

    t.test('Symbol.toPrimitive', { skip: !hasSymbolToPrimitive }, st => {
        const overriddenObject = { toString: st.fail, valueOf: st.fail };
        overriddenObject[Symbol.toPrimitive] = function(hint) {
            return String(hint);
        };

        st.equal(
            toPrimitive(overriddenObject),
            'default',
            'object with Symbol.toPrimitive + no hint invokes that'
        );
        st.equal(
            toPrimitive(overriddenObject, Number),
            'number',
            'object with Symbol.toPrimitive + hint Number invokes that'
        );
        st.equal(
            toPrimitive(overriddenObject, String),
            'string',
            'object with Symbol.toPrimitive + hint String invokes that'
        );

        const nullToPrimitive = {
            toString: coercibleObject.toString,
            valueOf: coercibleObject.valueOf,
        };
        nullToPrimitive[Symbol.toPrimitive] = null;
        st.equal(
            toPrimitive(nullToPrimitive),
            toPrimitive(coercibleObject),
            'object with no hint + null Symbol.toPrimitive ignores it'
        );
        st.equal(
            toPrimitive(nullToPrimitive, Number),
            toPrimitive(coercibleObject, Number),
            'object with hint Number + null Symbol.toPrimitive ignores it'
        );
        st.equal(
            toPrimitive(nullToPrimitive, String),
            toPrimitive(coercibleObject, String),
            'object with hint String + null Symbol.toPrimitive ignores it'
        );

        st.test('exceptions', sst => {
            const nonFunctionToPrimitive = {
                toString: sst.fail,
                valueOf: sst.fail,
            };
            nonFunctionToPrimitive[Symbol.toPrimitive] = {};
            sst.throws(
                toPrimitive.bind(null, nonFunctionToPrimitive),
                TypeError,
                'Symbol.toPrimitive returning a non-function throws'
            );

            const uncoercibleToPrimitive = {
                toString: sst.fail,
                valueOf: sst.fail,
            };
            uncoercibleToPrimitive[Symbol.toPrimitive] = function(hint) {
                return {
                    toString() {
                        return hint;
                    },
                };
            };
            sst.throws(
                toPrimitive.bind(null, uncoercibleToPrimitive),
                TypeError,
                'Symbol.toPrimitive returning an object throws'
            );

            const throwingToPrimitive = {
                toString: sst.fail,
                valueOf: sst.fail,
            };
            throwingToPrimitive[Symbol.toPrimitive] = function(hint) {
                throw new RangeError(hint);
            };
            sst.throws(
                toPrimitive.bind(null, throwingToPrimitive),
                RangeError,
                'Symbol.toPrimitive throwing throws'
            );

            sst.end();
        });

        st.end();
    });

    t.test('exceptions', st => {
        st.throws(
            toPrimitive.bind(null, uncoercibleObject),
            TypeError,
            'uncoercibleObject throws a TypeError'
        );
        st.throws(
            toPrimitive.bind(null, uncoercibleObject, Number),
            TypeError,
            'uncoercibleObject with hint Number throws a TypeError'
        );
        st.throws(
            toPrimitive.bind(null, uncoercibleObject, String),
            TypeError,
            'uncoercibleObject with hint String throws a TypeError'
        );

        st.throws(
            toPrimitive.bind(null, uncoercibleFnObject),
            TypeError,
            'uncoercibleFnObject throws a TypeError'
        );
        st.throws(
            toPrimitive.bind(null, uncoercibleFnObject, Number),
            TypeError,
            'uncoercibleFnObject with hint Number throws a TypeError'
        );
        st.throws(
            toPrimitive.bind(null, uncoercibleFnObject, String),
            TypeError,
            'uncoercibleFnObject with hint String throws a TypeError'
        );
        st.end();
    });
    t.end();
});
